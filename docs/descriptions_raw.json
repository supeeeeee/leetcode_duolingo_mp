{
  "count": 119,
  "rows": [
    {
      "id": "q001",
      "leetcodeSlug": "two-sum",
      "track": "extra",
      "question": "【两数之和】 最优解法的核心数据结构是什么？",
      "description": "给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。"
    },
    {
      "id": "q002",
      "leetcodeSlug": "best-time-to-buy-and-sell-stock",
      "track": "core",
      "question": "【买卖股票的最佳时机】 单次交易最优策略是？",
      "description": "给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。"
    },
    {
      "id": "q003",
      "leetcodeSlug": "product-of-array-except-self",
      "track": "extra",
      "question": "【除自身以外数组的乘积】 不使用除法时，应组合哪两类信息？",
      "description": "给你一个整数数组 nums，返回一个数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。请不要使用除法，且在 O(n) 时间复杂度内完成。"
    },
    {
      "id": "q004",
      "leetcodeSlug": "maximum-subarray",
      "track": "core",
      "question": "【最大子数组和】 Kadane 算法的状态转移是？",
      "description": "给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。"
    },
    {
      "id": "q005",
      "leetcodeSlug": "merge-intervals",
      "track": "extra",
      "question": "【合并区间】 为什么先按左端点排序？",
      "description": "以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi]。请你合并所有重叠的区间，并返回一个不重叠的区间数组。"
    },
    {
      "id": "q006",
      "leetcodeSlug": "rotate-array",
      "track": "extra",
      "question": "【轮转数组】 O(1) 额外空间常用做法是？",
      "description": "给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。尝试使用 O(1) 额外空间完成。"
    },
    {
      "id": "q007",
      "leetcodeSlug": "move-zeroes",
      "track": "extra",
      "question": "【移动零】 保持相对顺序的线性做法是？",
      "description": "给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。必须在原数组上操作。"
    },
    {
      "id": "q008",
      "leetcodeSlug": "majority-element",
      "track": "extra",
      "question": "【多数元素】 Boyer-Moore 的关键思想是？",
      "description": "给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。"
    },
    {
      "id": "q009",
      "leetcodeSlug": "next-permutation",
      "track": "extra",
      "question": "【下一个排列】 从后往前找到第一个下降位后，下一步是？",
      "description": "给你一个整数数组 nums ，找出 nums 的下一个字典序更大的排列。如果不存在下一个更大的排列，则将数组重新按升序排列。"
    },
    {
      "id": "q010",
      "leetcodeSlug": "sort-colors",
      "track": "extra",
      "question": "【颜色分类】 荷兰国旗问题需要几个指针？",
      "description": "给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。"
    },
    {
      "id": "q011",
      "leetcodeSlug": "first-missing-positive",
      "track": "extra",
      "question": "【缺失的第一个正数】 O(n)+O(1) 的核心是？",
      "description": "给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。请你设计并实现时间复杂度为 O(n) 且仅使用常数级别额外空间的算法。"
    },
    {
      "id": "q012",
      "leetcodeSlug": "trapping-rain-water",
      "track": "core",
      "question": "【接雨水】 双指针做法每步更新哪一个边界？",
      "description": "给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。"
    },
    {
      "id": "q013",
      "leetcodeSlug": "group-anagrams",
      "track": "extra",
      "question": "【字母异位词分组】 作为 key 的常用设计是？",
      "description": "给你一个字符串数组，请你将字母异位词组合在一起。可以按任意顺序返回结果列表。字母异位词是由重新排列源字符串的字母得到的一个新字符串。"
    },
    {
      "id": "q014",
      "leetcodeSlug": "valid-anagram",
      "track": "extra",
      "question": "【有效的字母异位词】 最稳妥解法是？",
      "description": "给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。"
    },
    {
      "id": "q015",
      "leetcodeSlug": "subarray-sum-equals-k",
      "track": "core",
      "question": "【和为 K 的子数组】 前缀和+哈希的查找条件是？",
      "description": "给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。"
    },
    {
      "id": "q016",
      "leetcodeSlug": "longest-consecutive-sequence",
      "track": "extra",
      "question": "【最长连续序列】 O(n) 做法的关键是？",
      "description": "给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请设计并实现时间复杂度为 O(n) 的算法。"
    },
    {
      "id": "q017",
      "leetcodeSlug": "lru-cache",
      "track": "extra",
      "question": "【LRU 缓存】 满足 O(1) get/put 的组合是？",
      "description": "设计并实现一个满足 LRU (最近最少使用) 缓存约束的数据结构。支持 get(key) 和 put(key, value) 操作，且复杂度均为 O(1)。"
    },
    {
      "id": "q018",
      "leetcodeSlug": "top-k-frequent-elements",
      "track": "extra",
      "question": "【前 K 个高频元素】 典型做法是？",
      "description": "给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按任意顺序返回答案。"
    },
    {
      "id": "q019",
      "leetcodeSlug": "4sum-ii",
      "track": "extra",
      "question": "【四数相加 II】 降维思路是？",
      "description": "给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足四个数组对应元素之和为 0。"
    },
    {
      "id": "q020",
      "leetcodeSlug": "decode-ways",
      "track": "extra",
      "question": "【字符串解码计数场景】 为什么常用 Map 而不是数组？",
      "description": "本题对应《字符串解码计数场景》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 hashmaps 相关方法中完成复杂度优化。"
    },
    {
      "id": "q021",
      "leetcodeSlug": "happy-number",
      "track": "extra",
      "question": "【快乐数】 判环常用哪个结构？",
      "description": "编写一个算法来判断一个数 n 是不是快乐数。快乐数定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，最终变更为 1。"
    },
    {
      "id": "q022",
      "leetcodeSlug": "isomorphic-strings",
      "track": "extra",
      "question": "【同构字符串】 需要保证什么？",
      "description": "给定两个字符串 s 和 t ，判断它们是否是同构的。如果 s 中的字符可以按某种替换规则得到 t ，则两个字符串同构。"
    },
    {
      "id": "q023",
      "leetcodeSlug": "3sum",
      "track": "core",
      "question": "【三数之和】 去重通常在何处做？",
      "description": "给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。"
    },
    {
      "id": "q024",
      "leetcodeSlug": "container-with-most-water",
      "track": "extra",
      "question": "【盛最多水的容器】 每次移动哪边指针？",
      "description": "给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。"
    },
    {
      "id": "q025",
      "leetcodeSlug": "remove-duplicates-from-sorted-array",
      "track": "core",
      "question": "【删除有序数组重复项】 slow 指针含义是？",
      "description": "给你一个升序排列的数组 nums ，请你原地删除重复出现的元素，使每个元素只出现一次 ，返回删除后数组的新长度。"
    },
    {
      "id": "q026",
      "leetcodeSlug": "palindrome-linked-list",
      "track": "extra",
      "question": "【回文链表】 O(1) 空间常见流程是？",
      "description": "给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。"
    },
    {
      "id": "q027",
      "leetcodeSlug": "two-sum-ii-input-array-is-sorted",
      "track": "extra",
      "question": "【有序数组两数之和 II】 为何可用双指针？",
      "description": "给定一个已升序排列的整数数组 numbers 和目标值 target，找出两数之和等于 target 的下标（返回从1开始的索引）。"
    },
    {
      "id": "q028",
      "leetcodeSlug": "remove-nth-node-from-end-of-list",
      "track": "core",
      "question": "【删除链表倒数第 N 个节点】 经典做法是？",
      "description": "给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。"
    },
    {
      "id": "q029",
      "leetcodeSlug": "intersection-of-two-linked-lists",
      "track": "extra",
      "question": "【相交链表】 O(1) 空间解法核心是？",
      "description": "给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。"
    },
    {
      "id": "q030",
      "leetcodeSlug": "trapping-rain-water-two-pointers",
      "track": "extra",
      "question": "【接雨水双指针】 leftMax < rightMax 时计算哪侧？",
      "description": "给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。"
    },
    {
      "id": "q031",
      "leetcodeSlug": "longest-substring-without-repeating-characters",
      "track": "core",
      "question": "【无重复字符的最长子串】 窗口左边界何时移动？",
      "description": "给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。"
    },
    {
      "id": "q032",
      "leetcodeSlug": "minimum-window-substring",
      "track": "core",
      "question": "【最小覆盖子串】 valid 的含义通常是？",
      "description": "给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串。"
    },
    {
      "id": "q033",
      "leetcodeSlug": "find-all-anagrams-in-a-string",
      "track": "core",
      "question": "【找到字符串中所有字母异位词】 常用策略是？",
      "description": "给定两个字符串 s 和 p，找到 s 中所有 p 的异位词的子串，返回这些子串的起始索引。"
    },
    {
      "id": "q034",
      "leetcodeSlug": "minimum-size-subarray-sum",
      "track": "extra",
      "question": "【长度最小的子数组】 正数数组时可用滑窗的原因是？",
      "description": "给定一个含有 n 个正整数的数组和一个正整数 target 。找出该数组中满足其和 ≥ target 的长度最小的连续子数组，并返回其长度。"
    },
    {
      "id": "q035",
      "leetcodeSlug": "max-consecutive-ones-iii",
      "track": "extra",
      "question": "【最大连续 1（可翻转 k 次）】 关键计数是？",
      "description": "给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回数组中连续 1 的最大个数。"
    },
    {
      "id": "q036",
      "leetcodeSlug": "substring-with-concatenation-of-all-words",
      "track": "extra",
      "question": "【串联所有单词的子串】 常见优化是？",
      "description": "本题对应《串联所有单词的子串》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 sliding_window 相关方法中完成复杂度优化。"
    },
    {
      "id": "q037",
      "leetcodeSlug": "fruit-into-baskets",
      "track": "extra",
      "question": "【水果成篮】 对应的数据结构是？",
      "description": "本题对应《水果成篮》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 sliding_window 相关方法中完成复杂度优化。"
    },
    {
      "id": "q038",
      "leetcodeSlug": "longest-repeating-character-replacement",
      "track": "extra",
      "question": "【替换后的最长重复字符】 窗口是否必须实时维护精确 maxFreq？",
      "description": "本题对应《替换后的最长重复字符》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 sliding_window 相关方法中完成复杂度优化。"
    },
    {
      "id": "q039",
      "leetcodeSlug": "reverse-linked-list",
      "track": "extra",
      "question": "【反转链表】 迭代解法每轮需要保存什么？",
      "description": "给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。"
    },
    {
      "id": "q040",
      "leetcodeSlug": "merge-two-sorted-lists",
      "track": "core",
      "question": "【合并两个有序链表】 常用技巧是？",
      "description": "将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。"
    },
    {
      "id": "q041",
      "leetcodeSlug": "linked-list-cycle",
      "track": "core",
      "question": "【链表有环】 为什么快慢指针可判环？",
      "description": "本题对应《链表有环》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 linked_list 相关方法中完成复杂度优化。"
    },
    {
      "id": "q042",
      "leetcodeSlug": "reorder-list",
      "track": "extra",
      "question": "【重排链表】 典型流程是？",
      "description": "本题对应《重排链表》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 linked_list 相关方法中完成复杂度优化。"
    },
    {
      "id": "q043",
      "leetcodeSlug": "reverse-nodes-in-k-group",
      "track": "extra",
      "question": "【K 个一组翻转链表】 一般需要先确认什么？",
      "description": "本题对应《K 个一组翻转链表》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 linked_list 相关方法中完成复杂度优化。"
    },
    {
      "id": "q044",
      "leetcodeSlug": "copy-list-with-random-pointer",
      "track": "extra",
      "question": "【复制带随机指针的链表】 O(1) 额外空间做法是？",
      "description": "本题对应《复制带随机指针的链表》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 linked_list 相关方法中完成复杂度优化。"
    },
    {
      "id": "q045",
      "leetcodeSlug": "sort-list",
      "track": "extra",
      "question": "【排序链表】 最常用达到 O(n log n) 的方法是？",
      "description": "本题对应《排序链表》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 linked_list 相关方法中完成复杂度优化。"
    },
    {
      "id": "q046",
      "leetcodeSlug": "palindrome-linked-list-review",
      "track": "extra",
      "question": "【回文链表】 结束后是否建议恢复链表？",
      "description": "给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。"
    },
    {
      "id": "q047",
      "leetcodeSlug": "linked-list-cycle-ii",
      "track": "core",
      "question": "【环形链表 II】 找入环点时的关键是？",
      "description": "本题对应《环形链表 II》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 linked_list 相关方法中完成复杂度优化。"
    },
    {
      "id": "q048",
      "leetcodeSlug": "remove-duplicates-from-sorted-list-ii",
      "track": "extra",
      "question": "【删除排序链表重复元素 II】 需要删除哪些节点？",
      "description": "本题对应《删除排序链表重复元素 II》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 linked_list 相关方法中完成复杂度优化。"
    },
    {
      "id": "q049",
      "leetcodeSlug": "valid-parentheses",
      "track": "extra",
      "question": "【有效括号】 核心数据结构是？",
      "description": "给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。"
    },
    {
      "id": "q050",
      "leetcodeSlug": "min-stack",
      "track": "extra",
      "question": "【最小栈】 常见做法是？",
      "description": "设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。"
    },
    {
      "id": "q051",
      "leetcodeSlug": "daily-temperatures",
      "track": "extra",
      "question": "【每日温度】 为什么用单调递减栈？",
      "description": "本题对应《每日温度》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 stack_queue 相关方法中完成复杂度优化。"
    },
    {
      "id": "q052",
      "leetcodeSlug": "largest-rectangle-in-histogram",
      "track": "core",
      "question": "【柱状图最大矩形】 经典解法是？",
      "description": "本题对应《柱状图最大矩形》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 stack_queue 相关方法中完成复杂度优化。"
    },
    {
      "id": "q053",
      "leetcodeSlug": "evaluate-reverse-polish-notation",
      "track": "extra",
      "question": "【逆波兰表达式求值】 遇到运算符时应？",
      "description": "本题对应《逆波兰表达式求值》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 stack_queue 相关方法中完成复杂度优化。"
    },
    {
      "id": "q054",
      "leetcodeSlug": "decode-string",
      "track": "extra",
      "question": "【字符串解码】 `3【a2【c】】` 推荐用什么实现？",
      "description": "本题对应《字符串解码》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 stack_queue 相关方法中完成复杂度优化。"
    },
    {
      "id": "q055",
      "leetcodeSlug": "sliding-window-maximum",
      "track": "extra",
      "question": "【滑动窗口最大值】 O(n) 解法常用？",
      "description": "本题对应《滑动窗口最大值》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 stack_queue 相关方法中完成复杂度优化。"
    },
    {
      "id": "q056",
      "leetcodeSlug": "implement-queue-using-stacks",
      "track": "extra",
      "question": "【实现队列用栈】 摊还 O(1) 的关键是？",
      "description": "本题对应《实现队列用栈》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 stack_queue 相关方法中完成复杂度优化。"
    },
    {
      "id": "q057",
      "leetcodeSlug": "binary-search",
      "track": "core",
      "question": "【二分查找】 mid 的安全写法是？",
      "description": "给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。"
    },
    {
      "id": "q058",
      "leetcodeSlug": "search-in-rotated-sorted-array",
      "track": "core",
      "question": "【搜索旋转排序数组】 如何判断有序半边？",
      "description": "本题对应《搜索旋转排序数组》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 binary_search 相关方法中完成复杂度优化。"
    },
    {
      "id": "q059",
      "leetcodeSlug": "find-peak-element",
      "track": "extra",
      "question": "【寻找峰值】 为什么可用二分？",
      "description": "本题对应《寻找峰值》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 binary_search 相关方法中完成复杂度优化。"
    },
    {
      "id": "q060",
      "leetcodeSlug": "find-first-and-last-position-of-element-in-sorted-array",
      "track": "extra",
      "question": "【在排序数组中查找元素首尾位置】 常见做法是？",
      "description": "本题对应《在排序数组中查找元素首尾位置》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 binary_search 相关方法中完成复杂度优化。"
    },
    {
      "id": "q061",
      "leetcodeSlug": "sqrtx",
      "track": "extra",
      "question": "【x 的平方根】 二分答案空间时判定条件是？",
      "description": "本题对应《x 的平方根》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 binary_search 相关方法中完成复杂度优化。"
    },
    {
      "id": "q062",
      "leetcodeSlug": "find-minimum-in-rotated-sorted-array",
      "track": "core",
      "question": "【寻找旋转数组最小值】 判断依据是？",
      "description": "本题对应《寻找旋转数组最小值》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 binary_search 相关方法中完成复杂度优化。"
    },
    {
      "id": "q063",
      "leetcodeSlug": "koko-eating-bananas",
      "track": "extra",
      "question": "【Koko 吃香蕉】 本质是什么？",
      "description": "本题对应《Koko 吃香蕉》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 binary_search 相关方法中完成复杂度优化。"
    },
    {
      "id": "q064",
      "leetcodeSlug": "search-a-2d-matrix",
      "track": "extra",
      "question": "【搜索二维矩阵】 若矩阵行首递增可视作？",
      "description": "本题对应《搜索二维矩阵》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 binary_search 相关方法中完成复杂度优化。"
    },
    {
      "id": "q065",
      "leetcodeSlug": "binary-tree-level-order-traversal",
      "track": "extra",
      "question": "【二叉树层序遍历】 典型结构是？",
      "description": "给你二叉树的根节点 root ，返回其节点值的层序遍历。（即逐层地，从左到右访问所有节点）。"
    },
    {
      "id": "q066",
      "leetcodeSlug": "validate-binary-search-tree",
      "track": "core",
      "question": "【验证二叉搜索树】 递归法常用约束是？",
      "description": "给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。"
    },
    {
      "id": "q067",
      "leetcodeSlug": "lowest-common-ancestor-of-a-binary-tree",
      "track": "extra",
      "question": "【最近公共祖先】 递归返回逻辑是？",
      "description": "给定一个二叉树, 找到该树中两个指定节点的最近公共祖先 (LCA)。"
    },
    {
      "id": "q068",
      "leetcodeSlug": "invert-binary-tree",
      "track": "extra",
      "question": "【翻转二叉树】 本质操作是？",
      "description": "给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。"
    },
    {
      "id": "q069",
      "leetcodeSlug": "path-sum",
      "track": "extra",
      "question": "【路径总和】 DFS 参数常用什么？",
      "description": "本题对应《路径总和》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 trees 相关方法中完成复杂度优化。"
    },
    {
      "id": "q070",
      "leetcodeSlug": "diameter-of-binary-tree",
      "track": "extra",
      "question": "【二叉树直径】 需要在 DFS 中维护什么？",
      "description": "本题对应《二叉树直径》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 trees 相关方法中完成复杂度优化。"
    },
    {
      "id": "q071",
      "leetcodeSlug": "balanced-binary-tree",
      "track": "extra",
      "question": "【平衡二叉树】 高效做法是？",
      "description": "本题对应《平衡二叉树》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 trees 相关方法中完成复杂度优化。"
    },
    {
      "id": "q072",
      "leetcodeSlug": "binary-tree-maximum-path-sum",
      "track": "extra",
      "question": "【二叉树最大路径和】 路径贡献如何定义？",
      "description": "本题对应《二叉树最大路径和》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 trees 相关方法中完成复杂度优化。"
    },
    {
      "id": "q073",
      "leetcodeSlug": "construct-binary-tree-from-preorder-and-inorder-traversal",
      "track": "extra",
      "question": "【从前序与中序构造二叉树】 核心映射是？",
      "description": "本题对应《从前序与中序构造二叉树》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 trees 相关方法中完成复杂度优化。"
    },
    {
      "id": "q074",
      "leetcodeSlug": "kth-smallest-element-in-a-bst",
      "track": "extra",
      "question": "【二叉搜索树第 K 小】 中序遍历性质是？",
      "description": "本题对应《二叉搜索树第 K 小》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 trees 相关方法中完成复杂度优化。"
    },
    {
      "id": "q075",
      "leetcodeSlug": "serialize-and-deserialize-binary-tree",
      "track": "extra",
      "question": "【序列化二叉树】 需要记录空节点的原因是？",
      "description": "本题对应《序列化二叉树》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 trees 相关方法中完成复杂度优化。"
    },
    {
      "id": "q076",
      "leetcodeSlug": "symmetric-tree",
      "track": "extra",
      "question": "【对称二叉树】 递归比较哪两棵子树？",
      "description": "本题对应《对称二叉树》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 trees 相关方法中完成复杂度优化。"
    },
    {
      "id": "q077",
      "leetcodeSlug": "number-of-islands",
      "track": "core",
      "question": "【岛屿数量】 访问陆地后为什么要立刻标记？",
      "description": "给你一个由 '1'（陆地）和 '0'（水）组成的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围。"
    },
    {
      "id": "q078",
      "leetcodeSlug": "course-schedule",
      "track": "core",
      "question": "【课程表】 判环通常用什么？",
      "description": "你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。在选修某些课程之前需要一些先修课程。判断你是否可能完成所有课程的学习。"
    },
    {
      "id": "q079",
      "leetcodeSlug": "clone-graph",
      "track": "extra",
      "question": "【克隆图】 为什么要哈希 old->new？",
      "description": "本题对应《克隆图》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 graphs 相关方法中完成复杂度优化。"
    },
    {
      "id": "q080",
      "leetcodeSlug": "rotting-oranges",
      "track": "extra",
      "question": "【腐烂的橘子】 为什么是多源 BFS？",
      "description": "本题对应《腐烂的橘子》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 graphs 相关方法中完成复杂度优化。"
    },
    {
      "id": "q081",
      "leetcodeSlug": "word-ladder",
      "track": "extra",
      "question": "【单词接龙】 适合哪种搜索？",
      "description": "本题对应《单词接龙》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 graphs 相关方法中完成复杂度优化。"
    },
    {
      "id": "q082",
      "leetcodeSlug": "surrounded-regions",
      "track": "extra",
      "question": "【被围绕的区域】 边界 O 处理思路是？",
      "description": "本题对应《被围绕的区域》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 graphs 相关方法中完成复杂度优化。"
    },
    {
      "id": "q083",
      "leetcodeSlug": "redundant-connection",
      "track": "extra",
      "question": "【冗余连接】 无向图找成环边常用？",
      "description": "本题对应《冗余连接》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 graphs 相关方法中完成复杂度优化。"
    },
    {
      "id": "q084",
      "leetcodeSlug": "network-delay-time",
      "track": "extra",
      "question": "【网络延迟时间】 边权非负时常用算法？",
      "description": "本题对应《网络延迟时间》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 graphs 相关方法中完成复杂度优化。"
    },
    {
      "id": "q085",
      "leetcodeSlug": "climbing-stairs",
      "track": "extra",
      "question": "【爬楼梯】 状态转移是？",
      "description": "假设你正在爬楼梯。需要 n 阶才能到达楼顶。每次你可以爬 1 或 2 个台阶。有多少种不同的方法可以爬到楼顶？"
    },
    {
      "id": "q086",
      "leetcodeSlug": "house-robber",
      "track": "extra",
      "question": "【打家劫舍】 线性 DP 转移是？",
      "description": "你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统。"
    },
    {
      "id": "q087",
      "leetcodeSlug": "coin-change",
      "track": "extra",
      "question": "【零钱兑换】 完全背包转移方向是？",
      "description": "给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的最少的硬币个数。"
    },
    {
      "id": "q088",
      "leetcodeSlug": "longest-increasing-subsequence",
      "track": "core",
      "question": "【最长递增子序列】 O(n log n) 优化依赖？",
      "description": "给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。"
    },
    {
      "id": "q089",
      "leetcodeSlug": "longest-common-subsequence",
      "track": "extra",
      "question": "【最长公共子序列】 当字符相等时？",
      "description": "给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在公共子序列，返回 0。"
    },
    {
      "id": "q090",
      "leetcodeSlug": "partition-equal-subset-sum",
      "track": "core",
      "question": "【分割等和子集】 目标可转化为？",
      "description": "本题对应《分割等和子集》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 dynamic_programming 相关方法中完成复杂度优化。"
    },
    {
      "id": "q091",
      "leetcodeSlug": "edit-distance",
      "track": "extra",
      "question": "【编辑距离】 三种操作对应？",
      "description": "给你两个单词 word1 和 word2，请返回将 word1 转换成 word2 所使用的最少操作数。你可以对一个单词进行插入、删除、替换操作。"
    },
    {
      "id": "q092",
      "leetcodeSlug": "unique-paths",
      "track": "extra",
      "question": "【不同路径】 机器人只能右/下时转移是？",
      "description": "本题对应《不同路径》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 dynamic_programming 相关方法中完成复杂度优化。"
    },
    {
      "id": "q093",
      "leetcodeSlug": "longest-palindromic-substring",
      "track": "extra",
      "question": "【最长回文子串】 中心扩展法复杂度通常是？",
      "description": "本题对应《最长回文子串》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 dynamic_programming 相关方法中完成复杂度优化。"
    },
    {
      "id": "q094",
      "leetcodeSlug": "word-break",
      "track": "extra",
      "question": "【单词拆分】 常见状态定义是？",
      "description": "本题对应《单词拆分》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 dynamic_programming 相关方法中完成复杂度优化。"
    },
    {
      "id": "q095",
      "leetcodeSlug": "maximal-square",
      "track": "extra",
      "question": "【最大正方形】 状态与哪个方向有关？",
      "description": "本题对应《最大正方形》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 dynamic_programming 相关方法中完成复杂度优化。"
    },
    {
      "id": "q096",
      "leetcodeSlug": "best-time-to-buy-and-sell-stock-with-cooldown",
      "track": "extra",
      "question": "【买卖股票含冷冻期】 需要几个状态？",
      "description": "本题对应《买卖股票含冷冻期》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 dynamic_programming 相关方法中完成复杂度优化。"
    },
    {
      "id": "q097",
      "leetcodeSlug": "permutations",
      "track": "core",
      "question": "【全排列】 回溯模板关键是？",
      "description": "给定一个不含重复数字的数组 nums ，返回其所有可能的全排列。你可以按任意顺序返回答案。"
    },
    {
      "id": "q098",
      "leetcodeSlug": "combination-sum",
      "track": "extra",
      "question": "【组合总和】 为避免重复组合，递归应？",
      "description": "本题对应《组合总和》。请依据原题定义实现算法，重点梳理输入输出、边界条件与不变量，并在 backtracking 相关方法中完成复杂度优化。"
    },
    {
      "id": "q099",
      "leetcodeSlug": "n-queens",
      "track": "core",
      "question": "【N 皇后】 剪枝时常维护哪些集合？",
      "description": "设计一个算法，将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。"
    },
    {
      "id": "q100",
      "leetcodeSlug": "top-k-frequent-elements-review",
      "track": "extra",
      "question": "【前 K 个高频元素】 Python 中常见库是？",
      "description": "给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按任意顺序返回答案。"
    },
    {
      "id": "q101",
      "leetcodeSlug": "search-insert-position",
      "track": "core",
      "question": "【搜索插入位置】 二分查找的正确边界策略是？",
      "description": "给定一个排序数组 nums 和一个目标值 target，如果 target 存在返回其下标；否则返回它将会被按顺序插入的位置。"
    },
    {
      "id": "q102",
      "leetcodeSlug": "combinations",
      "track": "core",
      "question": "【组合】 回溯中用于避免重复组合的关键是？",
      "description": "给定两个整数 n 和 k，返回 1..n 中所有可能的 k 个数的组合。"
    },
    {
      "id": "q103",
      "leetcodeSlug": "subsets",
      "track": "core",
      "question": "【子集】 生成所有子集的回溯策略是？",
      "description": "给你一个整数数组 nums，返回该数组所有可能的子集（幂集）。"
    },
    {
      "id": "q104",
      "leetcodeSlug": "maximum-depth-of-binary-tree",
      "track": "core",
      "question": "【二叉树最大深度】 DFS 递归的返回值通常表示？",
      "description": "给定二叉树 root，返回其最大深度（从根到最远叶子节点的最长路径节点数）。"
    },
    {
      "id": "q105",
      "leetcodeSlug": "minimum-depth-of-binary-tree",
      "track": "core",
      "question": "【二叉树的最小深度】 为什么常用 BFS 而不是 DFS？",
      "description": "给定一棵二叉树，找出其最小深度（从根节点到最近叶子节点的最短路径上的节点数）。"
    },
    {
      "id": "q106",
      "leetcodeSlug": "best-time-to-buy-and-sell-stock-iii",
      "track": "core",
      "question": "【股票 III】 最多两次交易的 DP 关键状态是？",
      "description": "给定 prices，最多完成两笔交易（买入+卖出为一笔），求最大利润（不能同时参与多笔交易）。"
    },
    {
      "id": "q107",
      "leetcodeSlug": "single-number",
      "track": "core",
      "question": "【只出现一次的数字】 使用异或的关键性质是？",
      "description": "给定非空整数数组，除一个元素只出现一次外，其余元素均出现两次，找出只出现一次的元素。"
    },
    {
      "id": "q108",
      "leetcodeSlug": "binary-tree-preorder-traversal",
      "track": "core",
      "question": "【二叉树前序遍历】 递归前序的“访问位置”是？",
      "description": "给定二叉树 root，返回其节点值的前序遍历。"
    },
    {
      "id": "q109",
      "leetcodeSlug": "power-of-two",
      "track": "core",
      "question": "【2 的幂】 位运算判断 2^k 的常用式子是？",
      "description": "给定一个整数 n，判断它是否为 2 的幂。"
    },
    {
      "id": "q110",
      "leetcodeSlug": "ugly-number-ii",
      "track": "core",
      "question": "【丑数 II】 求第 n 个丑数的常用方法是？",
      "description": "给定正整数 n，返回第 n 个丑数。丑数是只包含质因数 2、3、5 的正整数。"
    },
    {
      "id": "q111",
      "leetcodeSlug": "find-median-from-data-stream",
      "track": "core",
      "question": "【数据流的中位数】 常用的数据结构组合是？",
      "description": "设计数据结构支持 addNum 与 findMedian，在不断添加数字的数据流中实时返回中位数。"
    },
    {
      "id": "q112",
      "leetcodeSlug": "range-sum-query-2d-immutable",
      "track": "core",
      "question": "【二维区域和检索】 构建二维前缀和的核心公式是？",
      "description": "给定二维矩阵，预处理后支持多次查询任意子矩形的元素和。"
    },
    {
      "id": "q113",
      "leetcodeSlug": "range-addition",
      "track": "core",
      "question": "【区间加法】 差分数组 diff 的含义是？",
      "description": "给定长度为 length 的数组初始为 0，多次对区间 [start,end] 加上增量，返回最终数组。"
    },
    {
      "id": "q114",
      "leetcodeSlug": "coin-change-ii",
      "track": "core",
      "question": "【零钱兑换 II】 组合数（不限次数）背包的遍历顺序是？",
      "description": "给定硬币面额 coins 与总金额 amount，计算可以凑成 amount 的组合数（每种硬币可无限使用）。"
    },
    {
      "id": "q115",
      "leetcodeSlug": "permutation-in-string",
      "track": "core",
      "question": "【字符串的排列】 滑动窗口需要维护的核心变量是？",
      "description": "给定 s1 和 s2，判断 s2 是否包含 s1 的任意排列作为子串。"
    },
    {
      "id": "q116",
      "leetcodeSlug": "insert-into-a-binary-search-tree",
      "track": "core",
      "question": "【BST 插入】 插入操作的递归方向由什么决定？",
      "description": "给定二叉搜索树 root 与插入值 val，返回插入后的 BST 根节点。"
    },
    {
      "id": "q117",
      "leetcodeSlug": "open-the-lock",
      "track": "core",
      "question": "【打开转盘锁】 BFS 的“去重”通常用什么结构？",
      "description": "你有一个带四个拨轮的转盘锁，每次可以将某一位拨动 +1 或 -1（循环）。给定 deadends 与 target，求最少拨动次数。"
    },
    {
      "id": "q118",
      "leetcodeSlug": "middle-of-the-linked-list",
      "track": "core",
      "question": "【链表的中间结点】 快慢指针的步速关系是？",
      "description": "给定非空单链表 head，返回链表的中间结点；若有两个中间结点返回第二个。"
    },
    {
      "id": "q119",
      "leetcodeSlug": "squares-of-a-sorted-array",
      "track": "core",
      "question": "【有序数组的平方】 为什么可以用双指针从两端向中间？",
      "description": "给定按非递减顺序排序的整数数组 nums，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。"
    }
  ]
}