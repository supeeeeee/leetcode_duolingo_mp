{
  "meta": {
    "generatedAt": "2026-02-14T16:41:47.721Z",
    "source": "miniprogram/data/questions.js",
    "handbookSource": "LeetCode学习习题册.md",
    "totalQuestions": 100
  },
  "summary": {
    "errors": 0,
    "warnings": 1,
    "suggestions": 36,
    "handbookMappedTopics": [
      "two_pointers",
      "sliding_window",
      "binary_search",
      "arrays",
      "backtracking",
      "graphs",
      "dynamic_programming",
      "trees",
      "stack_queue"
    ],
    "handbookEntryCount": 43
  },
  "perQuestionSummary": {
    "q062": {
      "errors": 0,
      "warnings": 1,
      "suggestions": 0
    },
    "q002": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q003": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q004": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q006": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q007": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q008": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q009": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q010": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q011": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q012": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q014": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q015": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q016": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q018": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q019": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q020": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q021": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q022": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q024": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q025": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q030": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q033": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q034": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q035": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q036": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q037": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q038": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q086": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q088": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q089": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q090": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q091": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q092": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q094": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q095": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    },
    "q096": {
      "errors": 0,
      "warnings": 0,
      "suggestions": 1
    }
  },
  "questionDiagnostics": [
    {
      "id": "q001",
      "slug": "two-sum",
      "title": "两数之和",
      "topicId": "arrays",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def twoSum(nums, target):",
            "hashmap = {}",
            "for i, num in enumerate(nums):"
          ],
          "symbols": [
            "twoSum",
            "enumerate"
          ]
        },
        "java": {
          "firstLines": [
            "public int[] twoSum(int[] nums, int target) {",
            "Map<Integer, Integer> map = new HashMap<>();",
            "for (int i = 0; i < nums.length; i++) {"
          ],
          "symbols": [
            "twoSum"
          ]
        },
        "cpp": {
          "firstLines": [
            "vector<int> twoSum(vector<int>& nums, int target) {",
            "unordered_map<int, int> hashmap;",
            "for (int i = 0; i < nums.size(); i++) {"
          ],
          "symbols": [
            "twoSum"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q002",
      "slug": "best-time-to-buy-and-sell-stock",
      "title": "买卖股票的最佳时机",
      "topicId": "arrays",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 买卖股票的最佳时机 (best-time-to-buy-and-sell-stock)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 买卖股票的最佳时机 (best-time-to-buy-and-sell-stock)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 买卖股票的最佳时机 (best-time-to-buy-and-sell-stock)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q003",
      "slug": "product-of-array-except-self",
      "title": "除自身以外数组的乘积",
      "topicId": "arrays",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 除自身以外数组的乘积 (product-of-array-except-self)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 除自身以外数组的乘积 (product-of-array-except-self)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 除自身以外数组的乘积 (product-of-array-except-self)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q004",
      "slug": "maximum-subarray",
      "title": "最大子数组和",
      "topicId": "arrays",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 最大子数组和 (maximum-subarray)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 最大子数组和 (maximum-subarray)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 最大子数组和 (maximum-subarray)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q005",
      "slug": "merge-intervals",
      "title": "合并区间",
      "topicId": "arrays",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def merge(intervals):",
            "intervals.sort(key=lambda x: x[0])",
            "merged = []"
          ],
          "symbols": [
            "merge"
          ]
        },
        "java": {
          "firstLines": [
            "public int[][] merge(int[][] intervals) {",
            "Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));",
            "LinkedList<int[]> merged = new LinkedList<>();"
          ],
          "symbols": [
            "merge"
          ]
        },
        "cpp": {
          "firstLines": [
            "vector<vector<int>> merge(vector<vector<int>>& intervals) {",
            "if (intervals.empty()) return {};",
            "sort(intervals.begin(), intervals.end());"
          ],
          "symbols": [
            "merge"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q006",
      "slug": "rotate-array",
      "title": "轮转数组",
      "topicId": "arrays",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 轮转数组 (rotate-array)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 轮转数组 (rotate-array)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 轮转数组 (rotate-array)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q007",
      "slug": "move-zeroes",
      "title": "移动零",
      "topicId": "arrays",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 移动零 (move-zeroes)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 移动零 (move-zeroes)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 移动零 (move-zeroes)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q008",
      "slug": "majority-element",
      "title": "多数元素",
      "topicId": "arrays",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 多数元素 (majority-element)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 多数元素 (majority-element)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 多数元素 (majority-element)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q009",
      "slug": "next-permutation",
      "title": "下一个排列",
      "topicId": "arrays",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 下一个排列 (next-permutation)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 下一个排列 (next-permutation)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 下一个排列 (next-permutation)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q010",
      "slug": "sort-colors",
      "title": "颜色分类",
      "topicId": "arrays",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 颜色分类 (sort-colors)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 颜色分类 (sort-colors)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 颜色分类 (sort-colors)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q011",
      "slug": "first-missing-positive",
      "title": "缺失的第一个正数",
      "topicId": "arrays",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 缺失的第一个正数 (first-missing-positive)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 缺失的第一个正数 (first-missing-positive)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 缺失的第一个正数 (first-missing-positive)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q012",
      "slug": "trapping-rain-water",
      "title": "接雨水",
      "topicId": "arrays",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 接雨水 (trapping-rain-water)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 接雨水 (trapping-rain-water)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 接雨水 (trapping-rain-water)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q013",
      "slug": "group-anagrams",
      "title": "字母异位词分组",
      "topicId": "hashmaps",
      "fingerprints": {
        "python": {
          "firstLines": [
            "from collections import defaultdict",
            "def groupAnagrams(strs):",
            "groups = defaultdict(list)"
          ],
          "symbols": [
            "groupAnagrams",
            "list"
          ]
        },
        "java": {
          "firstLines": [
            "public List<List<String>> groupAnagrams(String[] strs) {",
            "Map<String, List<String>> groups = new HashMap<>();",
            "for (String s : strs) {"
          ],
          "symbols": [
            "groupAnagrams",
            "String"
          ]
        },
        "cpp": {
          "firstLines": [
            "vector<vector<string>> groupAnagrams(vector<string>& strs) {",
            "unordered_map<string, vector<string>> groups;",
            "for (string s : strs) {"
          ],
          "symbols": [
            "groupAnagrams"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": false,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q014",
      "slug": "valid-anagram",
      "title": "有效的字母异位词",
      "topicId": "hashmaps",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 有效的字母异位词 (valid-anagram)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 有效的字母异位词 (valid-anagram)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 有效的字母异位词 (valid-anagram)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": false,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q015",
      "slug": "subarray-sum-equals-k",
      "title": "和为 K 的子数组",
      "topicId": "hashmaps",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 和为 K 的子数组 (subarray-sum-equals-k)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 和为 K 的子数组 (subarray-sum-equals-k)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 和为 K 的子数组 (subarray-sum-equals-k)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": false,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q016",
      "slug": "longest-consecutive-sequence",
      "title": "最长连续序列",
      "topicId": "hashmaps",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 最长连续序列 (longest-consecutive-sequence)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 最长连续序列 (longest-consecutive-sequence)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 最长连续序列 (longest-consecutive-sequence)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": false,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q017",
      "slug": "lru-cache",
      "title": "LRU 缓存",
      "topicId": "hashmaps",
      "fingerprints": {
        "python": {
          "firstLines": [
            "from collections import OrderedDict",
            "class LRUCache:",
            "def __init__(self, capacity: int):"
          ],
          "symbols": [
            "__init__",
            "get",
            "put",
            "LRUCache",
            "len"
          ]
        },
        "java": {
          "firstLines": [
            "class LRUCache extends LinkedHashMap<Integer, Integer> {",
            "private int capacity;",
            "public LRUCache(int capacity) {"
          ],
          "symbols": [
            "LRUCache",
            "get",
            "put",
            "removeEldestEntry",
            "size"
          ]
        },
        "cpp": {
          "firstLines": [
            "class LRUCache {",
            "int cap;",
            "list<pair<int, int>> l;"
          ],
          "symbols": [
            "LRUCache",
            "get",
            "put"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": false,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q018",
      "slug": "top-k-frequent-elements",
      "title": "前 K 个高频元素",
      "topicId": "hashmaps",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 前 K 个高频元素 (top-k-frequent-elements)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 前 K 个高频元素 (top-k-frequent-elements)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 前 K 个高频元素 (top-k-frequent-elements)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": false,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q019",
      "slug": "4sum-ii",
      "title": "四数相加 II",
      "topicId": "hashmaps",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 四数相加 II (4sum-ii)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 四数相加 II (4sum-ii)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 四数相加 II (4sum-ii)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": false,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q020",
      "slug": "decode-ways",
      "title": "字符串解码计数场景",
      "topicId": "hashmaps",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 字符串解码计数场景 (decode-ways)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 字符串解码计数场景 (decode-ways)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 字符串解码计数场景 (decode-ways)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": false,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q021",
      "slug": "happy-number",
      "title": "快乐数",
      "topicId": "hashmaps",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 快乐数 (happy-number)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 快乐数 (happy-number)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 快乐数 (happy-number)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": false,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q022",
      "slug": "isomorphic-strings",
      "title": "同构字符串",
      "topicId": "hashmaps",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 同构字符串 (isomorphic-strings)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 同构字符串 (isomorphic-strings)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 同构字符串 (isomorphic-strings)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": false,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q023",
      "slug": "3sum",
      "title": "三数之和",
      "topicId": "two_pointers",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def threeSum(nums):",
            "nums.sort()",
            "res = []"
          ],
          "symbols": [
            "threeSum",
            "range"
          ]
        },
        "java": {
          "firstLines": [
            "public List<List<Integer>> threeSum(int[] nums) {",
            "Arrays.sort(nums);",
            "List<List<Integer>> res = new ArrayList<>();"
          ],
          "symbols": [
            "threeSum",
            "if"
          ]
        },
        "cpp": {
          "firstLines": [
            "vector<vector<int>> threeSum(vector<int>& nums) {",
            "sort(nums.begin(), nums.end());",
            "vector<vector<int>> res;"
          ],
          "symbols": [
            "threeSum",
            "if"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q024",
      "slug": "container-with-most-water",
      "title": "盛最多水的容器",
      "topicId": "two_pointers",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 盛最多水的容器 (container-with-most-water)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 盛最多水的容器 (container-with-most-water)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 盛最多水的容器 (container-with-most-water)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q025",
      "slug": "remove-duplicates-from-sorted-array",
      "title": "删除有序数组重复项",
      "topicId": "two_pointers",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 删除有序数组重复项 (remove-duplicates-from-sorted-array)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 删除有序数组重复项 (remove-duplicates-from-sorted-array)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 删除有序数组重复项 (remove-duplicates-from-sorted-array)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q026",
      "slug": "palindrome-linked-list",
      "title": "回文链表",
      "topicId": "two_pointers",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def isPalindrome(head):",
            "slow = fast = head",
            "while fast and fast.next:"
          ],
          "symbols": [
            "isPalindrome"
          ]
        },
        "java": {
          "firstLines": [
            "public boolean isPalindrome(ListNode head) {",
            "ListNode slow = head, fast = head;",
            "while (fast != null && fast.next != null) {"
          ],
          "symbols": [
            "isPalindrome"
          ]
        },
        "cpp": {
          "firstLines": [
            "bool isPalindrome(ListNode* head) {",
            "ListNode *slow = head, *fast = head;",
            "while (fast && fast->next) { slow = slow->next; fast = fast->next->next; }"
          ],
          "symbols": [
            "isPalindrome"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q027",
      "slug": "two-sum-ii-input-array-is-sorted",
      "title": "有序数组两数之和 II",
      "topicId": "two_pointers",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def twoSum(numbers, target):",
            "left, right = 0, len(numbers) - 1",
            "while left < right:"
          ],
          "symbols": [
            "twoSum"
          ]
        },
        "java": {
          "firstLines": [
            "public int[] twoSum(int[] numbers, int target) {",
            "int left = 0, right = numbers.length - 1;",
            "while (left < right) {"
          ],
          "symbols": [
            "twoSum"
          ]
        },
        "cpp": {
          "firstLines": [
            "vector<int> twoSum(vector<int>& numbers, int target) {",
            "int left = 0, right = (int)numbers.size() - 1;",
            "while (left < right) {"
          ],
          "symbols": [
            "twoSum"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q028",
      "slug": "remove-nth-node-from-end-of-list",
      "title": "删除链表倒数第 N 个节点",
      "topicId": "two_pointers",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def removeNthFromEnd(head, n):",
            "dummy = ListNode(0, head)",
            "fast = slow = dummy"
          ],
          "symbols": [
            "removeNthFromEnd",
            "range"
          ]
        },
        "java": {
          "firstLines": [
            "public ListNode removeNthFromEnd(ListNode head, int n) {",
            "ListNode dummy = new ListNode(0, head);",
            "ListNode fast = dummy, slow = dummy;"
          ],
          "symbols": [
            "removeNthFromEnd",
            "ListNode"
          ]
        },
        "cpp": {
          "firstLines": [
            "ListNode* removeNthFromEnd(ListNode* head, int n) {",
            "ListNode dummy(0, head);",
            "ListNode *fast = &dummy, *slow = &dummy;"
          ],
          "symbols": [
            "dummy"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q029",
      "slug": "intersection-of-two-linked-lists",
      "title": "相交链表",
      "topicId": "two_pointers",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def getIntersectionNode(headA, headB):",
            "p, q = headA, headB",
            "while p != q:"
          ],
          "symbols": [
            "getIntersectionNode"
          ]
        },
        "java": {
          "firstLines": [
            "public ListNode getIntersectionNode(ListNode headA, ListNode headB) {",
            "ListNode p = headA, q = headB;",
            "while (p != q) {"
          ],
          "symbols": [
            "getIntersectionNode"
          ]
        },
        "cpp": {
          "firstLines": [
            "ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {",
            "ListNode *p = headA, *q = headB;",
            "while (p != q) {"
          ],
          "symbols": []
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q030",
      "slug": "trapping-rain-water-two-pointers",
      "title": "接雨水双指针",
      "topicId": "two_pointers",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 接雨水双指针 (trapping-rain-water-two-pointers)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 接雨水双指针 (trapping-rain-water-two-pointers)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 接雨水双指针 (trapping-rain-water-two-pointers)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q031",
      "slug": "longest-substring-without-repeating-characters",
      "title": "无重复字符的最长子串",
      "topicId": "sliding_window",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def lengthOfLongestSubstring(s):",
            "char_map = {}",
            "left = 0"
          ],
          "symbols": [
            "lengthOfLongestSubstring",
            "enumerate"
          ]
        },
        "java": {
          "firstLines": [
            "public int lengthOfLongestSubstring(String s) {",
            "Map<Character, Integer> map = new HashMap<>();",
            "int left = 0, maxLen = 0;"
          ],
          "symbols": [
            "lengthOfLongestSubstring"
          ]
        },
        "cpp": {
          "firstLines": [
            "int lengthOfLongestSubstring(string s) {",
            "unordered_map<char, int> map;",
            "int left = 0, maxLen = 0;"
          ],
          "symbols": [
            "lengthOfLongestSubstring"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q032",
      "slug": "minimum-window-substring",
      "title": "最小覆盖子串",
      "topicId": "sliding_window",
      "fingerprints": {
        "python": {
          "firstLines": [
            "JavaScript:",
            "function minWindow(s, t) {",
            "const need = new Map();"
          ],
          "symbols": [
            "minWindow",
            "Map"
          ]
        },
        "java": {
          "firstLines": [
            "// 最小覆盖子串",
            "int solve(int[] arr) {",
            "int left = 0, ans = 0;"
          ],
          "symbols": [
            "solve"
          ]
        },
        "cpp": {
          "firstLines": [
            "// 最小覆盖子串",
            "int solve(vector<int>& arr) {",
            "int left = 0, ans = 0;"
          ],
          "symbols": [
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q033",
      "slug": "find-all-anagrams-in-a-string",
      "title": "找到字符串中所有字母异位词",
      "topicId": "sliding_window",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 找到字符串中所有字母异位词 (find-all-anagrams-in-a-string)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 找到字符串中所有字母异位词 (find-all-anagrams-in-a-string)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 找到字符串中所有字母异位词 (find-all-anagrams-in-a-string)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q034",
      "slug": "minimum-size-subarray-sum",
      "title": "长度最小的子数组",
      "topicId": "sliding_window",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 长度最小的子数组 (minimum-size-subarray-sum)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 长度最小的子数组 (minimum-size-subarray-sum)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 长度最小的子数组 (minimum-size-subarray-sum)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q035",
      "slug": "max-consecutive-ones-iii",
      "title": "最大连续 1（可翻转 k 次）",
      "topicId": "sliding_window",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 最大连续 1（可翻转 k 次） (max-consecutive-ones-iii)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 最大连续 1（可翻转 k 次） (max-consecutive-ones-iii)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 最大连续 1（可翻转 k 次） (max-consecutive-ones-iii)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q036",
      "slug": "substring-with-concatenation-of-all-words",
      "title": "串联所有单词的子串",
      "topicId": "sliding_window",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 串联所有单词的子串 (substring-with-concatenation-of-all-words)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 串联所有单词的子串 (substring-with-concatenation-of-all-words)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 串联所有单词的子串 (substring-with-concatenation-of-all-words)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q037",
      "slug": "fruit-into-baskets",
      "title": "水果成篮",
      "topicId": "sliding_window",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 水果成篮 (fruit-into-baskets)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 水果成篮 (fruit-into-baskets)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 水果成篮 (fruit-into-baskets)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q038",
      "slug": "longest-repeating-character-replacement",
      "title": "替换后的最长重复字符",
      "topicId": "sliding_window",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 替换后的最长重复字符 (longest-repeating-character-replacement)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 替换后的最长重复字符 (longest-repeating-character-replacement)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 替换后的最长重复字符 (longest-repeating-character-replacement)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q039",
      "slug": "reverse-linked-list",
      "title": "反转链表",
      "topicId": "linked_list",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def reverseList(head):",
            "prev = None",
            "curr = head"
          ],
          "symbols": [
            "reverseList"
          ]
        },
        "java": {
          "firstLines": [
            "public ListNode reverseList(ListNode head) {",
            "ListNode prev = null;",
            "ListNode curr = head;"
          ],
          "symbols": [
            "reverseList"
          ]
        },
        "cpp": {
          "firstLines": [
            "ListNode* reverseList(ListNode* head) {",
            "ListNode* prev = nullptr;",
            "ListNode* curr = head;"
          ],
          "symbols": []
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": false,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q040",
      "slug": "merge-two-sorted-lists",
      "title": "合并两个有序链表",
      "topicId": "linked_list",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# 合并两个有序链表",
            "def solve(head):",
            "dummy = ListNode(0, head)"
          ],
          "symbols": [
            "solve"
          ]
        },
        "java": {
          "firstLines": [
            "// 合并两个有序链表",
            "ListNode solve(ListNode head) {",
            "ListNode prev = null, cur = head;"
          ],
          "symbols": [
            "solve"
          ]
        },
        "cpp": {
          "firstLines": [
            "// 合并两个有序链表",
            "ListNode* solve(ListNode* head) {",
            "ListNode* prev = nullptr;"
          ],
          "symbols": []
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": false,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q041",
      "slug": "linked-list-cycle",
      "title": "链表有环",
      "topicId": "linked_list",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# 链表有环",
            "def solve(head):",
            "dummy = ListNode(0, head)"
          ],
          "symbols": [
            "solve"
          ]
        },
        "java": {
          "firstLines": [
            "// 链表有环",
            "ListNode solve(ListNode head) {",
            "ListNode prev = null, cur = head;"
          ],
          "symbols": [
            "solve"
          ]
        },
        "cpp": {
          "firstLines": [
            "// 链表有环",
            "ListNode* solve(ListNode* head) {",
            "ListNode* prev = nullptr;"
          ],
          "symbols": []
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": false,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q042",
      "slug": "reorder-list",
      "title": "重排链表",
      "topicId": "linked_list",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# 重排链表",
            "def solve(head):",
            "dummy = ListNode(0, head)"
          ],
          "symbols": [
            "solve"
          ]
        },
        "java": {
          "firstLines": [
            "// 重排链表",
            "ListNode solve(ListNode head) {",
            "ListNode prev = null, cur = head;"
          ],
          "symbols": [
            "solve"
          ]
        },
        "cpp": {
          "firstLines": [
            "// 重排链表",
            "ListNode* solve(ListNode* head) {",
            "ListNode* prev = nullptr;"
          ],
          "symbols": []
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": false,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q043",
      "slug": "reverse-nodes-in-k-group",
      "title": "K 个一组翻转链表",
      "topicId": "linked_list",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# K 个一组翻转链表",
            "def solve(head):",
            "dummy = ListNode(0, head)"
          ],
          "symbols": [
            "solve"
          ]
        },
        "java": {
          "firstLines": [
            "// K 个一组翻转链表",
            "ListNode solve(ListNode head) {",
            "ListNode prev = null, cur = head;"
          ],
          "symbols": [
            "solve"
          ]
        },
        "cpp": {
          "firstLines": [
            "// K 个一组翻转链表",
            "ListNode* solve(ListNode* head) {",
            "ListNode* prev = nullptr;"
          ],
          "symbols": []
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": false,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q044",
      "slug": "copy-list-with-random-pointer",
      "title": "复制带随机指针的链表",
      "topicId": "linked_list",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# 复制带随机指针的链表",
            "def solve(head):",
            "dummy = ListNode(0, head)"
          ],
          "symbols": [
            "solve"
          ]
        },
        "java": {
          "firstLines": [
            "// 复制带随机指针的链表",
            "ListNode solve(ListNode head) {",
            "ListNode prev = null, cur = head;"
          ],
          "symbols": [
            "solve"
          ]
        },
        "cpp": {
          "firstLines": [
            "// 复制带随机指针的链表",
            "ListNode* solve(ListNode* head) {",
            "ListNode* prev = nullptr;"
          ],
          "symbols": []
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": false,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q045",
      "slug": "sort-list",
      "title": "排序链表",
      "topicId": "linked_list",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# 排序链表",
            "def solve(head):",
            "dummy = ListNode(0, head)"
          ],
          "symbols": [
            "solve"
          ]
        },
        "java": {
          "firstLines": [
            "// 排序链表",
            "ListNode solve(ListNode head) {",
            "ListNode prev = null, cur = head;"
          ],
          "symbols": [
            "solve"
          ]
        },
        "cpp": {
          "firstLines": [
            "// 排序链表",
            "ListNode* solve(ListNode* head) {",
            "ListNode* prev = nullptr;"
          ],
          "symbols": []
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": false,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q046",
      "slug": "palindrome-linked-list-review",
      "title": "回文链表",
      "topicId": "linked_list",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# 回文链表",
            "def solve(head):",
            "dummy = ListNode(0, head)"
          ],
          "symbols": [
            "solve"
          ]
        },
        "java": {
          "firstLines": [
            "// 回文链表",
            "ListNode solve(ListNode head) {",
            "ListNode prev = null, cur = head;"
          ],
          "symbols": [
            "solve"
          ]
        },
        "cpp": {
          "firstLines": [
            "// 回文链表",
            "ListNode* solve(ListNode* head) {",
            "ListNode* prev = nullptr;"
          ],
          "symbols": []
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": false,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q047",
      "slug": "linked-list-cycle-ii",
      "title": "环形链表 II",
      "topicId": "linked_list",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# 环形链表 II",
            "def solve(head):",
            "dummy = ListNode(0, head)"
          ],
          "symbols": [
            "solve"
          ]
        },
        "java": {
          "firstLines": [
            "// 环形链表 II",
            "ListNode solve(ListNode head) {",
            "ListNode prev = null, cur = head;"
          ],
          "symbols": [
            "solve"
          ]
        },
        "cpp": {
          "firstLines": [
            "// 环形链表 II",
            "ListNode* solve(ListNode* head) {",
            "ListNode* prev = nullptr;"
          ],
          "symbols": []
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": false,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q048",
      "slug": "remove-duplicates-from-sorted-list-ii",
      "title": "删除排序链表重复元素 II",
      "topicId": "linked_list",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# 删除排序链表重复元素 II",
            "def solve(head):",
            "dummy = ListNode(0, head)"
          ],
          "symbols": [
            "solve"
          ]
        },
        "java": {
          "firstLines": [
            "// 删除排序链表重复元素 II",
            "ListNode solve(ListNode head) {",
            "ListNode prev = null, cur = head;"
          ],
          "symbols": [
            "solve"
          ]
        },
        "cpp": {
          "firstLines": [
            "// 删除排序链表重复元素 II",
            "ListNode* solve(ListNode* head) {",
            "ListNode* prev = nullptr;"
          ],
          "symbols": []
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": false,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q049",
      "slug": "valid-parentheses",
      "title": "有效括号",
      "topicId": "stack_queue",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# 有效括号",
            "def solve(s):",
            "st = []"
          ],
          "symbols": [
            "solve"
          ]
        },
        "java": {
          "firstLines": [
            "// 有效括号",
            "boolean solve(String s) {",
            "Deque<Character> st = new ArrayDeque<>();"
          ],
          "symbols": [
            "solve"
          ]
        },
        "cpp": {
          "firstLines": [
            "// 有效括号",
            "bool solve(string s) {",
            "stack<char> st; unordered_map<char,char> mp{{')','('},{']','['},{'}','{'}};"
          ],
          "symbols": [
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q050",
      "slug": "min-stack",
      "title": "最小栈",
      "topicId": "stack_queue",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# 最小栈",
            "def solve(s):",
            "st = []"
          ],
          "symbols": [
            "solve"
          ]
        },
        "java": {
          "firstLines": [
            "// 最小栈",
            "boolean solve(String s) {",
            "Deque<Character> st = new ArrayDeque<>();"
          ],
          "symbols": [
            "solve"
          ]
        },
        "cpp": {
          "firstLines": [
            "// 最小栈",
            "bool solve(string s) {",
            "stack<char> st; unordered_map<char,char> mp{{')','('},{']','['},{'}','{'}};"
          ],
          "symbols": [
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q051",
      "slug": "daily-temperatures",
      "title": "每日温度",
      "topicId": "stack_queue",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def solve(tokens):",
            "st = []",
            "for t in tokens:"
          ],
          "symbols": [
            "solve"
          ]
        },
        "java": {
          "firstLines": [
            "int solve(String[] tokens) {",
            "Deque<Integer> st = new ArrayDeque<>();",
            "for (String t : tokens) {"
          ],
          "symbols": [
            "solve",
            "if"
          ]
        },
        "cpp": {
          "firstLines": [
            "int solve(vector<string>& tokens) {",
            "stack<int> st;",
            "for (auto &t : tokens) {"
          ],
          "symbols": [
            "solve",
            "if"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q052",
      "slug": "largest-rectangle-in-histogram",
      "title": "柱状图最大矩形",
      "topicId": "stack_queue",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def solve(tokens):",
            "st = []",
            "for t in tokens:"
          ],
          "symbols": [
            "solve"
          ]
        },
        "java": {
          "firstLines": [
            "int solve(String[] tokens) {",
            "Deque<Integer> st = new ArrayDeque<>();",
            "for (String t : tokens) {"
          ],
          "symbols": [
            "solve",
            "if"
          ]
        },
        "cpp": {
          "firstLines": [
            "int solve(vector<string>& tokens) {",
            "stack<int> st;",
            "for (auto &t : tokens) {"
          ],
          "symbols": [
            "solve",
            "if"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q053",
      "slug": "evaluate-reverse-polish-notation",
      "title": "逆波兰表达式求值",
      "topicId": "stack_queue",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def solve(tokens):",
            "st = []",
            "for t in tokens:"
          ],
          "symbols": [
            "solve"
          ]
        },
        "java": {
          "firstLines": [
            "int solve(String[] tokens) {",
            "Deque<Integer> st = new ArrayDeque<>();",
            "for (String t : tokens) {"
          ],
          "symbols": [
            "solve",
            "if"
          ]
        },
        "cpp": {
          "firstLines": [
            "int solve(vector<string>& tokens) {",
            "stack<int> st;",
            "for (auto &t : tokens) {"
          ],
          "symbols": [
            "solve",
            "if"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q054",
      "slug": "decode-string",
      "title": "字符串解码",
      "topicId": "stack_queue",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def solve(tokens):",
            "st = []",
            "for t in tokens:"
          ],
          "symbols": [
            "solve"
          ]
        },
        "java": {
          "firstLines": [
            "int solve(String[] tokens) {",
            "Deque<Integer> st = new ArrayDeque<>();",
            "for (String t : tokens) {"
          ],
          "symbols": [
            "solve",
            "if"
          ]
        },
        "cpp": {
          "firstLines": [
            "int solve(vector<string>& tokens) {",
            "stack<int> st;",
            "for (auto &t : tokens) {"
          ],
          "symbols": [
            "solve",
            "if"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q055",
      "slug": "sliding-window-maximum",
      "title": "滑动窗口最大值",
      "topicId": "stack_queue",
      "fingerprints": {
        "python": {
          "firstLines": [
            "from collections import deque",
            "def maxSlidingWindow(nums, k):",
            "dq = deque()"
          ],
          "symbols": [
            "maxSlidingWindow",
            "enumerate"
          ]
        },
        "java": {
          "firstLines": [
            "public int[] maxSlidingWindow(int[] nums, int k) {",
            "Deque<Integer> dq = new ArrayDeque<>();",
            "int[] ans = new int[nums.length - k + 1];"
          ],
          "symbols": [
            "maxSlidingWindow"
          ]
        },
        "cpp": {
          "firstLines": [
            "vector<int> maxSlidingWindow(vector<int>& nums, int k) {",
            "deque<int> dq;",
            "vector<int> ans;"
          ],
          "symbols": [
            "maxSlidingWindow"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q056",
      "slug": "implement-queue-using-stacks",
      "title": "实现队列用栈",
      "topicId": "stack_queue",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def solve(tokens):",
            "st = []",
            "for t in tokens:"
          ],
          "symbols": [
            "solve"
          ]
        },
        "java": {
          "firstLines": [
            "int solve(String[] tokens) {",
            "Deque<Integer> st = new ArrayDeque<>();",
            "for (String t : tokens) {"
          ],
          "symbols": [
            "solve",
            "if"
          ]
        },
        "cpp": {
          "firstLines": [
            "int solve(vector<string>& tokens) {",
            "stack<int> st;",
            "for (auto &t : tokens) {"
          ],
          "symbols": [
            "solve",
            "if"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q057",
      "slug": "binary-search",
      "title": "二分查找",
      "topicId": "binary_search",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def search(nums, target):",
            "l, r = 0, len(nums) - 1",
            "while l <= r:"
          ],
          "symbols": [
            "search"
          ]
        },
        "java": {
          "firstLines": [
            "public int search(int[] nums, int target) {",
            "int l = 0, r = nums.length - 1;",
            "while (l <= r) {"
          ],
          "symbols": [
            "search"
          ]
        },
        "cpp": {
          "firstLines": [
            "int search(vector<int>& nums, int target) {",
            "int l = 0, r = nums.size() - 1;",
            "while (l <= r) {"
          ],
          "symbols": [
            "search"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q058",
      "slug": "search-in-rotated-sorted-array",
      "title": "搜索旋转排序数组",
      "topicId": "binary_search",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def search(nums, target):",
            "left, right = 0, len(nums) - 1",
            "while left <= right:"
          ],
          "symbols": [
            "search"
          ]
        },
        "java": {
          "firstLines": [
            "public int search(int[] nums, int target) {",
            "int left = 0, right = nums.length - 1;",
            "while (left <= right) {"
          ],
          "symbols": [
            "search"
          ]
        },
        "cpp": {
          "firstLines": [
            "int search(vector<int>& nums, int target) {",
            "int left = 0, right = (int)nums.size() - 1;",
            "while (left <= right) {"
          ],
          "symbols": [
            "search"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q059",
      "slug": "find-peak-element",
      "title": "寻找峰值",
      "topicId": "binary_search",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def findPeakElement(nums):",
            "left, right = 0, len(nums) - 1",
            "while left < right:"
          ],
          "symbols": [
            "findPeakElement"
          ]
        },
        "java": {
          "firstLines": [
            "public int findPeakElement(int[] nums) {",
            "int left = 0, right = nums.length - 1;",
            "while (left < right) {"
          ],
          "symbols": [
            "findPeakElement"
          ]
        },
        "cpp": {
          "firstLines": [
            "int findPeakElement(vector<int>& nums) {",
            "int left = 0, right = (int)nums.size() - 1;",
            "while (left < right) {"
          ],
          "symbols": [
            "findPeakElement"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q060",
      "slug": "find-first-and-last-position-of-element-in-sorted-array",
      "title": "在排序数组中查找元素首尾位置",
      "topicId": "binary_search",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def solve(nums, target):",
            "l, r = 0, len(nums) - 1",
            "while l <= r:"
          ],
          "symbols": [
            "solve"
          ]
        },
        "java": {
          "firstLines": [
            "int solve(int[] nums, int target) {",
            "int l = 0, r = nums.length - 1;",
            "while (l <= r) {"
          ],
          "symbols": [
            "solve"
          ]
        },
        "cpp": {
          "firstLines": [
            "int solve(vector<int>& nums, int target) {",
            "int l = 0, r = (int)nums.size() - 1;",
            "while (l <= r) {"
          ],
          "symbols": [
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q061",
      "slug": "sqrtx",
      "title": "x 的平方根",
      "topicId": "binary_search",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def mySqrt(x):",
            "left, right = 0, x",
            "while left <= right:"
          ],
          "symbols": [
            "mySqrt"
          ]
        },
        "java": {
          "firstLines": [
            "public int mySqrt(int x) {",
            "long left = 0, right = x;",
            "while (left <= right) {"
          ],
          "symbols": [
            "mySqrt"
          ]
        },
        "cpp": {
          "firstLines": [
            "int mySqrt(int x) {",
            "long long left = 0, right = x;",
            "while (left <= right) {"
          ],
          "symbols": [
            "mySqrt"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q062",
      "slug": "find-minimum-in-rotated-sorted-array",
      "title": "寻找旋转数组最小值",
      "topicId": "binary_search",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def solve(nums, target):",
            "l, r = 0, len(nums) - 1",
            "while l <= r:"
          ],
          "symbols": [
            "solve"
          ]
        },
        "java": {
          "firstLines": [
            "int solve(int[] nums, int target) {",
            "int l = 0, r = nums.length - 1;",
            "while (l <= r) {"
          ],
          "symbols": [
            "solve"
          ]
        },
        "cpp": {
          "firstLines": [
            "int solve(vector<int>& nums, int target) {",
            "int l = 0, r = (int)nums.size() - 1;",
            "while (l <= r) {"
          ],
          "symbols": [
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [
        "missing_expected_keywords"
      ],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q063",
      "slug": "koko-eating-bananas",
      "title": "Koko 吃香蕉",
      "topicId": "binary_search",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def minEatingSpeed(piles, h):",
            "left, right = 1, max(piles)",
            "while left < right:"
          ],
          "symbols": [
            "minEatingSpeed"
          ]
        },
        "java": {
          "firstLines": [
            "public int minEatingSpeed(int[] piles, int h) {",
            "int left = 1, right = Arrays.stream(piles).max().getAsInt();",
            "while (left < right) {"
          ],
          "symbols": [
            "minEatingSpeed"
          ]
        },
        "cpp": {
          "firstLines": [
            "int minEatingSpeed(vector<int>& piles, int h) {",
            "int left = 1, right = *max_element(piles.begin(), piles.end());",
            "while (left < right) {"
          ],
          "symbols": [
            "minEatingSpeed"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q064",
      "slug": "search-a-2d-matrix",
      "title": "搜索二维矩阵",
      "topicId": "binary_search",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def searchMatrix(matrix, target):",
            "m, n = len(matrix), len(matrix[0])",
            "left, right = 0, m * n - 1"
          ],
          "symbols": [
            "searchMatrix"
          ]
        },
        "java": {
          "firstLines": [
            "public boolean searchMatrix(int[][] matrix, int target) {",
            "int m = matrix.length, n = matrix[0].length;",
            "int left = 0, right = m * n - 1;"
          ],
          "symbols": [
            "searchMatrix"
          ]
        },
        "cpp": {
          "firstLines": [
            "bool searchMatrix(vector<vector<int>>& matrix, int target) {",
            "int m = matrix.size(), n = matrix[0].size();",
            "int left = 0, right = m * n - 1;"
          ],
          "symbols": [
            "searchMatrix"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q065",
      "slug": "binary-tree-level-order-traversal",
      "title": "二叉树层序遍历",
      "topicId": "trees",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def dfs(root):",
            "if not root: return 0",
            "left = dfs(root.left)"
          ],
          "symbols": [
            "dfs"
          ]
        },
        "java": {
          "firstLines": [
            "int dfs(TreeNode root) {",
            "if (root == null) return 0;",
            "int left = dfs(root.left);"
          ],
          "symbols": [
            "dfs"
          ]
        },
        "cpp": {
          "firstLines": [
            "int dfs(TreeNode* root) {",
            "if (!root) return 0;",
            "int left = dfs(root->left);"
          ],
          "symbols": [
            "dfs"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q066",
      "slug": "validate-binary-search-tree",
      "title": "验证二叉搜索树",
      "topicId": "trees",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def dfs(root):",
            "if not root: return 0",
            "left = dfs(root.left)"
          ],
          "symbols": [
            "dfs"
          ]
        },
        "java": {
          "firstLines": [
            "int dfs(TreeNode root) {",
            "if (root == null) return 0;",
            "int left = dfs(root.left);"
          ],
          "symbols": [
            "dfs"
          ]
        },
        "cpp": {
          "firstLines": [
            "int dfs(TreeNode* root) {",
            "if (!root) return 0;",
            "int left = dfs(root->left);"
          ],
          "symbols": [
            "dfs"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q067",
      "slug": "lowest-common-ancestor-of-a-binary-tree",
      "title": "最近公共祖先",
      "topicId": "trees",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def dfs(root):",
            "if not root: return 0",
            "left = dfs(root.left)"
          ],
          "symbols": [
            "dfs"
          ]
        },
        "java": {
          "firstLines": [
            "int dfs(TreeNode root) {",
            "if (root == null) return 0;",
            "int left = dfs(root.left);"
          ],
          "symbols": [
            "dfs"
          ]
        },
        "cpp": {
          "firstLines": [
            "int dfs(TreeNode* root) {",
            "if (!root) return 0;",
            "int left = dfs(root->left);"
          ],
          "symbols": [
            "dfs"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q068",
      "slug": "invert-binary-tree",
      "title": "翻转二叉树",
      "topicId": "trees",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def dfs(root):",
            "if not root: return 0",
            "left = dfs(root.left)"
          ],
          "symbols": [
            "dfs"
          ]
        },
        "java": {
          "firstLines": [
            "int dfs(TreeNode root) {",
            "if (root == null) return 0;",
            "int left = dfs(root.left);"
          ],
          "symbols": [
            "dfs"
          ]
        },
        "cpp": {
          "firstLines": [
            "int dfs(TreeNode* root) {",
            "if (!root) return 0;",
            "int left = dfs(root->left);"
          ],
          "symbols": [
            "dfs"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q069",
      "slug": "path-sum",
      "title": "路径总和",
      "topicId": "trees",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def dfs(root):",
            "if not root: return 0",
            "left = dfs(root.left)"
          ],
          "symbols": [
            "dfs"
          ]
        },
        "java": {
          "firstLines": [
            "int dfs(TreeNode root) {",
            "if (root == null) return 0;",
            "int left = dfs(root.left);"
          ],
          "symbols": [
            "dfs"
          ]
        },
        "cpp": {
          "firstLines": [
            "int dfs(TreeNode* root) {",
            "if (!root) return 0;",
            "int left = dfs(root->left);"
          ],
          "symbols": [
            "dfs"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q070",
      "slug": "diameter-of-binary-tree",
      "title": "二叉树直径",
      "topicId": "trees",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def dfs(root):",
            "if not root: return 0",
            "left = dfs(root.left)"
          ],
          "symbols": [
            "dfs"
          ]
        },
        "java": {
          "firstLines": [
            "int dfs(TreeNode root) {",
            "if (root == null) return 0;",
            "int left = dfs(root.left);"
          ],
          "symbols": [
            "dfs"
          ]
        },
        "cpp": {
          "firstLines": [
            "int dfs(TreeNode* root) {",
            "if (!root) return 0;",
            "int left = dfs(root->left);"
          ],
          "symbols": [
            "dfs"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q071",
      "slug": "balanced-binary-tree",
      "title": "平衡二叉树",
      "topicId": "trees",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def dfs(root):",
            "if not root: return 0",
            "left = dfs(root.left)"
          ],
          "symbols": [
            "dfs"
          ]
        },
        "java": {
          "firstLines": [
            "int dfs(TreeNode root) {",
            "if (root == null) return 0;",
            "int left = dfs(root.left);"
          ],
          "symbols": [
            "dfs"
          ]
        },
        "cpp": {
          "firstLines": [
            "int dfs(TreeNode* root) {",
            "if (!root) return 0;",
            "int left = dfs(root->left);"
          ],
          "symbols": [
            "dfs"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q072",
      "slug": "binary-tree-maximum-path-sum",
      "title": "二叉树最大路径和",
      "topicId": "trees",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def dfs(root):",
            "if not root: return 0",
            "left = dfs(root.left)"
          ],
          "symbols": [
            "dfs"
          ]
        },
        "java": {
          "firstLines": [
            "int dfs(TreeNode root) {",
            "if (root == null) return 0;",
            "int left = dfs(root.left);"
          ],
          "symbols": [
            "dfs"
          ]
        },
        "cpp": {
          "firstLines": [
            "int dfs(TreeNode* root) {",
            "if (!root) return 0;",
            "int left = dfs(root->left);"
          ],
          "symbols": [
            "dfs"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q073",
      "slug": "construct-binary-tree-from-preorder-and-inorder-traversal",
      "title": "从前序与中序构造二叉树",
      "topicId": "trees",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def buildTree(preorder, inorder):",
            "pos = {v: i for i, v in enumerate(inorder)}",
            "def dfs(pl, pr, il, ir):"
          ],
          "symbols": [
            "buildTree",
            "dfs",
            "enumerate"
          ]
        },
        "java": {
          "firstLines": [
            "public TreeNode buildTree(int[] preorder, int[] inorder) {",
            "Map<Integer, Integer> pos = new HashMap<>();",
            "for (int i = 0; i < inorder.length; i++) pos.put(inorder[i], i);"
          ],
          "symbols": [
            "buildTree",
            "dfs",
            "TreeNode"
          ]
        },
        "cpp": {
          "firstLines": [
            "TreeNode* dfs(vector<int>& pre, int pl, int pr, int il, int ir, unordered_map<int,int>& pos) {",
            "if (pl > pr) return nullptr;",
            "TreeNode* root = new TreeNode(pre[pl]);"
          ],
          "symbols": [
            "TreeNode"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q074",
      "slug": "kth-smallest-element-in-a-bst",
      "title": "二叉搜索树第 K 小",
      "topicId": "trees",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def dfs(root):",
            "if not root: return 0",
            "left = dfs(root.left)"
          ],
          "symbols": [
            "dfs"
          ]
        },
        "java": {
          "firstLines": [
            "int dfs(TreeNode root) {",
            "if (root == null) return 0;",
            "int left = dfs(root.left);"
          ],
          "symbols": [
            "dfs"
          ]
        },
        "cpp": {
          "firstLines": [
            "int dfs(TreeNode* root) {",
            "if (!root) return 0;",
            "int left = dfs(root->left);"
          ],
          "symbols": [
            "dfs"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q075",
      "slug": "serialize-and-deserialize-binary-tree",
      "title": "序列化二叉树",
      "topicId": "trees",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def dfs(root):",
            "if not root: return 0",
            "left = dfs(root.left)"
          ],
          "symbols": [
            "dfs"
          ]
        },
        "java": {
          "firstLines": [
            "int dfs(TreeNode root) {",
            "if (root == null) return 0;",
            "int left = dfs(root.left);"
          ],
          "symbols": [
            "dfs"
          ]
        },
        "cpp": {
          "firstLines": [
            "int dfs(TreeNode* root) {",
            "if (!root) return 0;",
            "int left = dfs(root->left);"
          ],
          "symbols": [
            "dfs"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q076",
      "slug": "symmetric-tree",
      "title": "对称二叉树",
      "topicId": "trees",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def dfs(root):",
            "if not root: return 0",
            "left = dfs(root.left)"
          ],
          "symbols": [
            "dfs"
          ]
        },
        "java": {
          "firstLines": [
            "int dfs(TreeNode root) {",
            "if (root == null) return 0;",
            "int left = dfs(root.left);"
          ],
          "symbols": [
            "dfs"
          ]
        },
        "cpp": {
          "firstLines": [
            "int dfs(TreeNode* root) {",
            "if (!root) return 0;",
            "int left = dfs(root->left);"
          ],
          "symbols": [
            "dfs"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q077",
      "slug": "number-of-islands",
      "title": "岛屿数量",
      "topicId": "graphs",
      "fingerprints": {
        "python": {
          "firstLines": [
            "from collections import deque",
            "def bfs(start, graph):",
            "q = deque([start])"
          ],
          "symbols": [
            "bfs"
          ]
        },
        "java": {
          "firstLines": [
            "void bfs(int start, List<Integer>[] g) {",
            "Queue<Integer> q = new LinkedList<>();",
            "boolean[] vis = new boolean[g.length];"
          ],
          "symbols": [
            "bfs"
          ]
        },
        "cpp": {
          "firstLines": [
            "void bfs(int start, vector<vector<int>>& g) {",
            "queue<int> q; vector<int> vis(g.size());",
            "q.push(start); vis[start] = 1;"
          ],
          "symbols": [
            "bfs",
            "vis"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q078",
      "slug": "course-schedule",
      "title": "课程表",
      "topicId": "graphs",
      "fingerprints": {
        "python": {
          "firstLines": [
            "from collections import deque",
            "def bfs(start, graph):",
            "q = deque([start])"
          ],
          "symbols": [
            "bfs"
          ]
        },
        "java": {
          "firstLines": [
            "void bfs(int start, List<Integer>[] g) {",
            "Queue<Integer> q = new LinkedList<>();",
            "boolean[] vis = new boolean[g.length];"
          ],
          "symbols": [
            "bfs"
          ]
        },
        "cpp": {
          "firstLines": [
            "void bfs(int start, vector<vector<int>>& g) {",
            "queue<int> q; vector<int> vis(g.size());",
            "q.push(start); vis[start] = 1;"
          ],
          "symbols": [
            "bfs",
            "vis"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q079",
      "slug": "clone-graph",
      "title": "克隆图",
      "topicId": "graphs",
      "fingerprints": {
        "python": {
          "firstLines": [
            "from collections import deque",
            "def bfs(start, graph):",
            "q = deque([start])"
          ],
          "symbols": [
            "bfs"
          ]
        },
        "java": {
          "firstLines": [
            "void bfs(int start, List<Integer>[] g) {",
            "Queue<Integer> q = new LinkedList<>();",
            "boolean[] vis = new boolean[g.length];"
          ],
          "symbols": [
            "bfs"
          ]
        },
        "cpp": {
          "firstLines": [
            "void bfs(int start, vector<vector<int>>& g) {",
            "queue<int> q; vector<int> vis(g.size());",
            "q.push(start); vis[start] = 1;"
          ],
          "symbols": [
            "bfs",
            "vis"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q080",
      "slug": "rotting-oranges",
      "title": "腐烂的橘子",
      "topicId": "graphs",
      "fingerprints": {
        "python": {
          "firstLines": [
            "from collections import deque",
            "def bfs(start, graph):",
            "q = deque([start])"
          ],
          "symbols": [
            "bfs"
          ]
        },
        "java": {
          "firstLines": [
            "void bfs(int start, List<Integer>[] g) {",
            "Queue<Integer> q = new LinkedList<>();",
            "boolean[] vis = new boolean[g.length];"
          ],
          "symbols": [
            "bfs"
          ]
        },
        "cpp": {
          "firstLines": [
            "void bfs(int start, vector<vector<int>>& g) {",
            "queue<int> q; vector<int> vis(g.size());",
            "q.push(start); vis[start] = 1;"
          ],
          "symbols": [
            "bfs",
            "vis"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q081",
      "slug": "word-ladder",
      "title": "单词接龙",
      "topicId": "graphs",
      "fingerprints": {
        "python": {
          "firstLines": [
            "from collections import deque",
            "def bfs(start, graph):",
            "q = deque([start])"
          ],
          "symbols": [
            "bfs"
          ]
        },
        "java": {
          "firstLines": [
            "void bfs(int start, List<Integer>[] g) {",
            "Queue<Integer> q = new LinkedList<>();",
            "boolean[] vis = new boolean[g.length];"
          ],
          "symbols": [
            "bfs"
          ]
        },
        "cpp": {
          "firstLines": [
            "void bfs(int start, vector<vector<int>>& g) {",
            "queue<int> q; vector<int> vis(g.size());",
            "q.push(start); vis[start] = 1;"
          ],
          "symbols": [
            "bfs",
            "vis"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q082",
      "slug": "surrounded-regions",
      "title": "被围绕的区域",
      "topicId": "graphs",
      "fingerprints": {
        "python": {
          "firstLines": [
            "from collections import deque",
            "def bfs(start, graph):",
            "q = deque([start])"
          ],
          "symbols": [
            "bfs"
          ]
        },
        "java": {
          "firstLines": [
            "void bfs(int start, List<Integer>[] g) {",
            "Queue<Integer> q = new LinkedList<>();",
            "boolean[] vis = new boolean[g.length];"
          ],
          "symbols": [
            "bfs"
          ]
        },
        "cpp": {
          "firstLines": [
            "void bfs(int start, vector<vector<int>>& g) {",
            "queue<int> q; vector<int> vis(g.size());",
            "q.push(start); vis[start] = 1;"
          ],
          "symbols": [
            "bfs",
            "vis"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q083",
      "slug": "redundant-connection",
      "title": "冗余连接",
      "topicId": "graphs",
      "fingerprints": {
        "python": {
          "firstLines": [
            "from collections import deque",
            "def bfs(start, graph):",
            "q = deque([start])"
          ],
          "symbols": [
            "bfs"
          ]
        },
        "java": {
          "firstLines": [
            "void bfs(int start, List<Integer>[] g) {",
            "Queue<Integer> q = new LinkedList<>();",
            "boolean[] vis = new boolean[g.length];"
          ],
          "symbols": [
            "bfs"
          ]
        },
        "cpp": {
          "firstLines": [
            "void bfs(int start, vector<vector<int>>& g) {",
            "queue<int> q; vector<int> vis(g.size());",
            "q.push(start); vis[start] = 1;"
          ],
          "symbols": [
            "bfs",
            "vis"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q084",
      "slug": "network-delay-time",
      "title": "网络延迟时间",
      "topicId": "graphs",
      "fingerprints": {
        "python": {
          "firstLines": [
            "from collections import deque",
            "def bfs(start, graph):",
            "q = deque([start])"
          ],
          "symbols": [
            "bfs"
          ]
        },
        "java": {
          "firstLines": [
            "void bfs(int start, List<Integer>[] g) {",
            "Queue<Integer> q = new LinkedList<>();",
            "boolean[] vis = new boolean[g.length];"
          ],
          "symbols": [
            "bfs"
          ]
        },
        "cpp": {
          "firstLines": [
            "void bfs(int start, vector<vector<int>>& g) {",
            "queue<int> q; vector<int> vis(g.size());",
            "q.push(start); vis[start] = 1;"
          ],
          "symbols": [
            "bfs",
            "vis"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q085",
      "slug": "climbing-stairs",
      "title": "爬楼梯",
      "topicId": "dynamic_programming",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def climbStairs(n):",
            "if n <= 2: return n",
            "a, b = 1, 2"
          ],
          "symbols": [
            "climbStairs",
            "range"
          ]
        },
        "java": {
          "firstLines": [
            "public int climbStairs(int n) {",
            "if (n <= 2) return n;",
            "int a = 1, b = 2;"
          ],
          "symbols": [
            "climbStairs"
          ]
        },
        "cpp": {
          "firstLines": [
            "int climbStairs(int n) {",
            "if (n <= 2) return n;",
            "int a = 1, b = 2;"
          ],
          "symbols": [
            "climbStairs"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q086",
      "slug": "house-robber",
      "title": "打家劫舍",
      "topicId": "dynamic_programming",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 打家劫舍 (house-robber)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 打家劫舍 (house-robber)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 打家劫舍 (house-robber)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q087",
      "slug": "coin-change",
      "title": "零钱兑换",
      "topicId": "dynamic_programming",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def coinChange(coins, amount):",
            "dp = [float('inf')] * (amount + 1)",
            "dp[0] = 0"
          ],
          "symbols": [
            "coinChange",
            "range"
          ]
        },
        "java": {
          "firstLines": [
            "public int coinChange(int[] coins, int amount) {",
            "int[] dp = new int[amount + 1];",
            "Arrays.fill(dp, amount + 1);"
          ],
          "symbols": [
            "coinChange"
          ]
        },
        "cpp": {
          "firstLines": [
            "int coinChange(vector<int>& coins, int amount) {",
            "vector<int> dp(amount + 1, amount + 1);",
            "dp[0] = 0;"
          ],
          "symbols": [
            "coinChange",
            "dp"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q088",
      "slug": "longest-increasing-subsequence",
      "title": "最长递增子序列",
      "topicId": "dynamic_programming",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 最长递增子序列 (longest-increasing-subsequence)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 最长递增子序列 (longest-increasing-subsequence)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 最长递增子序列 (longest-increasing-subsequence)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q089",
      "slug": "longest-common-subsequence",
      "title": "最长公共子序列",
      "topicId": "dynamic_programming",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 最长公共子序列 (longest-common-subsequence)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 最长公共子序列 (longest-common-subsequence)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 最长公共子序列 (longest-common-subsequence)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q090",
      "slug": "partition-equal-subset-sum",
      "title": "分割等和子集",
      "topicId": "dynamic_programming",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 分割等和子集 (partition-equal-subset-sum)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 分割等和子集 (partition-equal-subset-sum)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 分割等和子集 (partition-equal-subset-sum)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q091",
      "slug": "edit-distance",
      "title": "编辑距离",
      "topicId": "dynamic_programming",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 编辑距离 (edit-distance)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 编辑距离 (edit-distance)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 编辑距离 (edit-distance)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q092",
      "slug": "unique-paths",
      "title": "不同路径",
      "topicId": "dynamic_programming",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 不同路径 (unique-paths)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 不同路径 (unique-paths)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 不同路径 (unique-paths)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q093",
      "slug": "longest-palindromic-substring",
      "title": "最长回文子串",
      "topicId": "dynamic_programming",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def longestPalindrome(s):",
            "def expand(l, r):",
            "while l >= 0 and r < len(s) and s[l] == s[r]:"
          ],
          "symbols": [
            "longestPalindrome",
            "expand",
            "len",
            "range"
          ]
        },
        "java": {
          "firstLines": [
            "public String longestPalindrome(String s) {",
            "String ans = \"\";",
            "for (int i = 0; i < s.length(); i++) {"
          ],
          "symbols": [
            "longestPalindrome",
            "expand"
          ]
        },
        "cpp": {
          "firstLines": [
            "string expand(const string& s, int l, int r) {",
            "while (l >= 0 && r < (int)s.size() && s[l] == s[r]) { l--; r++; }",
            "return s.substr(l + 1, r - l - 1);"
          ],
          "symbols": [
            "expand",
            "longestPalindrome"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q094",
      "slug": "word-break",
      "title": "单词拆分",
      "topicId": "dynamic_programming",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 单词拆分 (word-break)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 单词拆分 (word-break)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 单词拆分 (word-break)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q095",
      "slug": "maximal-square",
      "title": "最大正方形",
      "topicId": "dynamic_programming",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 最大正方形 (maximal-square)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 最大正方形 (maximal-square)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 最大正方形 (maximal-square)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q096",
      "slug": "best-time-to-buy-and-sell-stock-with-cooldown",
      "title": "买卖股票含冷冻期",
      "topicId": "dynamic_programming",
      "fingerprints": {
        "python": {
          "firstLines": [
            "# TODO: 买卖股票含冷冻期 (best-time-to-buy-and-sell-stock-with-cooldown)",
            "# INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "def solve(*args, **kwargs):"
          ],
          "symbols": [
            "solve",
            "NotImplementedError"
          ]
        },
        "java": {
          "firstLines": [
            "// TODO: 买卖股票含冷冻期 (best-time-to-buy-and-sell-stock-with-cooldown)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve",
            "UnsupportedOperationException"
          ]
        },
        "cpp": {
          "firstLines": [
            "// TODO: 买卖股票含冷冻期 (best-time-to-buy-and-sell-stock-with-cooldown)",
            "// INTENTIONAL_MISMATCH_PLACEHOLDER: 原代码与题意不一致，待按题目补全。",
            "class Solution {"
          ],
          "symbols": [
            "Solution",
            "solve"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q097",
      "slug": "permutations",
      "title": "全排列",
      "topicId": "backtracking",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def backtrack(path, used, nums, ans):",
            "if len(path) == len(nums):",
            "ans.append(path[:]); return"
          ],
          "symbols": [
            "backtrack",
            "len",
            "enumerate"
          ]
        },
        "java": {
          "firstLines": [
            "void backtrack(List<Integer> path, boolean[] used, int[] nums, List<List<Integer>> ans) {",
            "if (path.size() == nums.length) { ans.add(new ArrayList<>(path)); return; }",
            "for (int i = 0; i < nums.length; i++) {"
          ],
          "symbols": [
            "backtrack"
          ]
        },
        "cpp": {
          "firstLines": [
            "void backtrack(vector<int>& path, vector<int>& used, vector<int>& nums, vector<vector<int>>& ans) {",
            "if (path.size() == nums.size()) { ans.push_back(path); return; }",
            "for (int i = 0; i < (int)nums.size(); i++) {"
          ],
          "symbols": [
            "backtrack"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q098",
      "slug": "combination-sum",
      "title": "组合总和",
      "topicId": "backtracking",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def backtrack(path, used, nums, ans):",
            "if len(path) == len(nums):",
            "ans.append(path[:]); return"
          ],
          "symbols": [
            "backtrack",
            "len",
            "enumerate"
          ]
        },
        "java": {
          "firstLines": [
            "void backtrack(List<Integer> path, boolean[] used, int[] nums, List<List<Integer>> ans) {",
            "if (path.size() == nums.length) { ans.add(new ArrayList<>(path)); return; }",
            "for (int i = 0; i < nums.length; i++) {"
          ],
          "symbols": [
            "backtrack"
          ]
        },
        "cpp": {
          "firstLines": [
            "void backtrack(vector<int>& path, vector<int>& used, vector<int>& nums, vector<vector<int>>& ans) {",
            "if (path.size() == nums.size()) { ans.push_back(path); return; }",
            "for (int i = 0; i < (int)nums.size(); i++) {"
          ],
          "symbols": [
            "backtrack"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q099",
      "slug": "n-queens",
      "title": "N 皇后",
      "topicId": "backtracking",
      "fingerprints": {
        "python": {
          "firstLines": [
            "def backtrack(path, used, nums, ans):",
            "if len(path) == len(nums):",
            "ans.append(path[:]); return"
          ],
          "symbols": [
            "backtrack",
            "len",
            "enumerate"
          ]
        },
        "java": {
          "firstLines": [
            "void backtrack(List<Integer> path, boolean[] used, int[] nums, List<List<Integer>> ans) {",
            "if (path.size() == nums.length) { ans.add(new ArrayList<>(path)); return; }",
            "for (int i = 0; i < nums.length; i++) {"
          ],
          "symbols": [
            "backtrack"
          ]
        },
        "cpp": {
          "firstLines": [
            "void backtrack(vector<int>& path, vector<int>& used, vector<int>& nums, vector<vector<int>>& ans) {",
            "if (path.size() == nums.size()) { ans.push_back(path); return; }",
            "for (int i = 0; i < (int)nums.size(); i++) {"
          ],
          "symbols": [
            "backtrack"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": true,
        "fragmentPresent": true,
        "uncertain": false
      }
    },
    {
      "id": "q100",
      "slug": "top-k-frequent-elements-review",
      "title": "前 K 个高频元素",
      "topicId": "heap",
      "fingerprints": {
        "python": {
          "firstLines": [
            "import heapq",
            "def topK(nums, k):",
            "from collections import Counter"
          ],
          "symbols": [
            "topK"
          ]
        },
        "java": {
          "firstLines": [
            "int[] topK(int[] nums, int k) {",
            "Map<Integer,Integer> cnt = new HashMap<>();",
            "for (int x : nums) cnt.put(x, cnt.getOrDefault(x, 0) + 1);"
          ],
          "symbols": [
            "topK"
          ]
        },
        "cpp": {
          "firstLines": [
            "vector<int> topK(vector<int>& nums, int k) {",
            "unordered_map<int,int> cnt;",
            "for (int x : nums) cnt[x]++;"
          ],
          "symbols": [
            "topK"
          ]
        }
      },
      "codeMismatchSignals": [],
      "handbookMapping": {
        "topicCovered": false,
        "fragmentPresent": true,
        "uncertain": false
      }
    }
  ],
  "errors": [],
  "warnings": [
    {
      "severity": "warning",
      "id": "q062",
      "leetcodeSlug": "find-minimum-in-rotated-sorted-array",
      "question": "【寻找旋转数组最小值】 判断依据是？",
      "field": "codeSnippet",
      "line": 2438,
      "message": "代码块与 slug 的关键词浅层匹配失败",
      "snippet": "left, right, mid",
      "suggestion": "核对该题代码是否对应当前题目"
    }
  ],
  "suggestions": [
    {
      "severity": "suggestion",
      "id": "q002",
      "leetcodeSlug": "best-time-to-buy-and-sell-stock",
      "question": "【买卖股票的最佳时机】 单次交易最优策略是？",
      "field": "codeSnippet",
      "line": 42,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "best-time-to-buy-and-sell-stock",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q003",
      "leetcodeSlug": "product-of-array-except-self",
      "question": "【除自身以外数组的乘积】 不使用除法时，应组合哪两类信息？",
      "field": "codeSnippet",
      "line": 82,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "product-of-array-except-self",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q004",
      "leetcodeSlug": "maximum-subarray",
      "question": "【最大子数组和】 Kadane 算法的状态转移是？",
      "field": "codeSnippet",
      "line": 122,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "maximum-subarray",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q006",
      "leetcodeSlug": "rotate-array",
      "question": "【轮转数组】 O(1) 额外空间常用做法是？",
      "field": "codeSnippet",
      "line": 202,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "rotate-array",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q007",
      "leetcodeSlug": "move-zeroes",
      "question": "【移动零】 保持相对顺序的线性做法是？",
      "field": "codeSnippet",
      "line": 242,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "move-zeroes",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q008",
      "leetcodeSlug": "majority-element",
      "question": "【多数元素】 Boyer-Moore 的关键思想是？",
      "field": "codeSnippet",
      "line": 282,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "majority-element",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q009",
      "leetcodeSlug": "next-permutation",
      "question": "【下一个排列】 从后往前找到第一个下降位后，下一步是？",
      "field": "codeSnippet",
      "line": 322,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "next-permutation",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q010",
      "leetcodeSlug": "sort-colors",
      "question": "【颜色分类】 荷兰国旗问题需要几个指针？",
      "field": "codeSnippet",
      "line": 362,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "sort-colors",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q011",
      "leetcodeSlug": "first-missing-positive",
      "question": "【缺失的第一个正数】 O(n)+O(1) 的核心是？",
      "field": "codeSnippet",
      "line": 402,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "first-missing-positive",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q012",
      "leetcodeSlug": "trapping-rain-water",
      "question": "【接雨水】 双指针做法每步更新哪一个边界？",
      "field": "codeSnippet",
      "line": 442,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "trapping-rain-water",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q014",
      "leetcodeSlug": "valid-anagram",
      "question": "【有效的字母异位词】 最稳妥解法是？",
      "field": "codeSnippet",
      "line": 522,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "valid-anagram",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q015",
      "leetcodeSlug": "subarray-sum-equals-k",
      "question": "【和为 K 的子数组】 前缀和+哈希的查找条件是？",
      "field": "codeSnippet",
      "line": 562,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "subarray-sum-equals-k",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q016",
      "leetcodeSlug": "longest-consecutive-sequence",
      "question": "【最长连续序列】 O(n) 做法的关键是？",
      "field": "codeSnippet",
      "line": 602,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "longest-consecutive-sequence",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q018",
      "leetcodeSlug": "top-k-frequent-elements",
      "question": "【前 K 个高频元素】 典型做法是？",
      "field": "codeSnippet",
      "line": 682,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "top-k-frequent-elements",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q019",
      "leetcodeSlug": "4sum-ii",
      "question": "【四数相加 II】 降维思路是？",
      "field": "codeSnippet",
      "line": 722,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "4sum-ii",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q020",
      "leetcodeSlug": "decode-ways",
      "question": "【字符串解码计数场景】 为什么常用 Map 而不是数组？",
      "field": "codeSnippet",
      "line": 762,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "decode-ways",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q021",
      "leetcodeSlug": "happy-number",
      "question": "【快乐数】 判环常用哪个结构？",
      "field": "codeSnippet",
      "line": 802,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "happy-number",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q022",
      "leetcodeSlug": "isomorphic-strings",
      "question": "【同构字符串】 需要保证什么？",
      "field": "codeSnippet",
      "line": 842,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "isomorphic-strings",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q024",
      "leetcodeSlug": "container-with-most-water",
      "question": "【盛最多水的容器】 每次移动哪边指针？",
      "field": "codeSnippet",
      "line": 922,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "container-with-most-water",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q025",
      "leetcodeSlug": "remove-duplicates-from-sorted-array",
      "question": "【删除有序数组重复项】 slow 指针含义是？",
      "field": "codeSnippet",
      "line": 962,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "remove-duplicates-from-sorted-array",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q030",
      "leetcodeSlug": "trapping-rain-water-two-pointers",
      "question": "【接雨水双指针】 leftMax < rightMax 时计算哪侧？",
      "field": "codeSnippet",
      "line": 1162,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "trapping-rain-water-two-pointers",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q033",
      "leetcodeSlug": "find-all-anagrams-in-a-string",
      "question": "【找到字符串中所有字母异位词】 常用策略是？",
      "field": "codeSnippet",
      "line": 1280,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "find-all-anagrams-in-a-string",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q034",
      "leetcodeSlug": "minimum-size-subarray-sum",
      "question": "【长度最小的子数组】 正数数组时可用滑窗的原因是？",
      "field": "codeSnippet",
      "line": 1320,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "minimum-size-subarray-sum",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q035",
      "leetcodeSlug": "max-consecutive-ones-iii",
      "question": "【最大连续 1（可翻转 k 次）】 关键计数是？",
      "field": "codeSnippet",
      "line": 1360,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "max-consecutive-ones-iii",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q036",
      "leetcodeSlug": "substring-with-concatenation-of-all-words",
      "question": "【串联所有单词的子串】 常见优化是？",
      "field": "codeSnippet",
      "line": 1400,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "substring-with-concatenation-of-all-words",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q037",
      "leetcodeSlug": "fruit-into-baskets",
      "question": "【水果成篮】 对应的数据结构是？",
      "field": "codeSnippet",
      "line": 1440,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "fruit-into-baskets",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q038",
      "leetcodeSlug": "longest-repeating-character-replacement",
      "question": "【替换后的最长重复字符】 窗口是否必须实时维护精确 maxFreq？",
      "field": "codeSnippet",
      "line": 1480,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "longest-repeating-character-replacement",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q086",
      "leetcodeSlug": "house-robber",
      "question": "【打家劫舍】 线性 DP 转移是？",
      "field": "codeSnippet",
      "line": 3396,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "house-robber",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q088",
      "leetcodeSlug": "longest-increasing-subsequence",
      "question": "【最长递增子序列】 O(n log n) 优化依赖？",
      "field": "codeSnippet",
      "line": 3476,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "longest-increasing-subsequence",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q089",
      "leetcodeSlug": "longest-common-subsequence",
      "question": "【最长公共子序列】 当字符相等时？",
      "field": "codeSnippet",
      "line": 3516,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "longest-common-subsequence",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q090",
      "leetcodeSlug": "partition-equal-subset-sum",
      "question": "【分割等和子集】 目标可转化为？",
      "field": "codeSnippet",
      "line": 3556,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "partition-equal-subset-sum",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q091",
      "leetcodeSlug": "edit-distance",
      "question": "【编辑距离】 三种操作对应？",
      "field": "codeSnippet",
      "line": 3596,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "edit-distance",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q092",
      "leetcodeSlug": "unique-paths",
      "question": "【不同路径】 机器人只能右/下时转移是？",
      "field": "codeSnippet",
      "line": 3636,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "unique-paths",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q094",
      "leetcodeSlug": "word-break",
      "question": "【单词拆分】 常见状态定义是？",
      "field": "codeSnippet",
      "line": 3716,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "word-break",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q095",
      "leetcodeSlug": "maximal-square",
      "question": "【最大正方形】 状态与哪个方向有关？",
      "field": "codeSnippet",
      "line": 3756,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "maximal-square",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    },
    {
      "severity": "suggestion",
      "id": "q096",
      "leetcodeSlug": "best-time-to-buy-and-sell-stock-with-cooldown",
      "question": "【买卖股票含冷冻期】 需要几个状态？",
      "field": "codeSnippet",
      "line": 3796,
      "message": "该题代码块已按低风险策略留空 TODO，后续可补齐正式实现",
      "snippet": "best-time-to-buy-and-sell-stock-with-cooldown",
      "suggestion": "优先参考题目 slug 对应官方题解或习题册模板补全"
    }
  ]
}
