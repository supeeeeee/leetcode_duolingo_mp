/*
  Fix EXTRA questions that were previously uncovered due to incorrect / placeholder snippets.

  Targets (19):
  - binary-tree-maximum-path-sum
  - clone-graph
  - combination-sum
  - copy-list-with-random-pointer
  - kth-smallest-element-in-a-bst
  - network-delay-time
  - redundant-connection
  - reverse-nodes-in-k-group
  - rotting-oranges
  - serialize-and-deserialize-binary-tree
  - sort-list
  - surrounded-regions
  - word-ladder

  NOTE:
  Some of the 19 already had correct implementations (e.g. first-missing-positive,
  construct-binary-tree-from-preorder-and-inorder-traversal, longest-palindromic-substring,
  lru-cache, sliding-window-maximum, substring-with-concatenation-of-all-words).

  Usage:
    node scripts/fix_extra_uncovered_snippets.js
*/

const fs = require('fs');
const path = require('path');

const questionsPath = path.join(__dirname, '..', 'miniprogram', 'data', 'questions.js');
const questions = require(questionsPath);

const fixes = {
  'binary-tree-maximum-path-sum': {
    python: `def maxPathSum(root):\n    ans = float('-inf')\n    def gain(node):\n        nonlocal ans\n        if not node:\n            return 0\n        left = max(gain(node.left), 0)\n        right = max(gain(node.right), 0)\n        ans = max(ans, node.val + left + right)\n        return node.val + max(left, right)\n    gain(root)\n    return ans\n`,
    java: `public int maxPathSum(TreeNode root) {\n    int[] ans = new int[]{Integer.MIN_VALUE};\n    gain(root, ans);\n    return ans[0];\n}\nprivate int gain(TreeNode node, int[] ans) {\n    if (node == null) return 0;\n    int left = Math.max(gain(node.left, ans), 0);\n    int right = Math.max(gain(node.right, ans), 0);\n    ans[0] = Math.max(ans[0], node.val + left + right);\n    return node.val + Math.max(left, right);\n}\n`,
    cpp: `int maxPathSum(TreeNode* root) {\n    int ans = INT_MIN;\n    function<int(TreeNode*)> gain = [&](TreeNode* node){\n        if(!node) return 0;\n        int left = max(gain(node->left), 0);\n        int right = max(gain(node->right), 0);\n        ans = max(ans, node->val + left + right);\n        return node->val + max(left, right);\n    };\n    gain(root);\n    return ans;\n}\n`
  },

  'clone-graph': {
    python: `def cloneGraph(node):\n    if not node:\n        return None\n    mp = {}\n    def dfs(x):\n        if x in mp:\n            return mp[x]\n        copy = Node(x.val)\n        mp[x] = copy\n        copy.neighbors = [dfs(n) for n in x.neighbors]\n        return copy\n    return dfs(node)\n`,
    java: `public Node cloneGraph(Node node) {\n    if (node == null) return null;\n    Map<Node, Node> map = new HashMap<>();\n    return dfs(node, map);\n}\nprivate Node dfs(Node node, Map<Node, Node> map) {\n    if (map.containsKey(node)) return map.get(node);\n    Node copy = new Node(node.val);\n    map.put(node, copy);\n    for (Node nei : node.neighbors) {\n        copy.neighbors.add(dfs(nei, map));\n    }\n    return copy;\n}\n`,
    cpp: `Node* cloneGraph(Node* node) {\n    if (!node) return nullptr;\n    unordered_map<Node*, Node*> mp;\n    function<Node*(Node*)> dfs = [&](Node* x){\n        if (mp.count(x)) return mp[x];\n        Node* copy = new Node(x->val);\n        mp[x] = copy;\n        for (auto nei: x->neighbors) copy->neighbors.push_back(dfs(nei));\n        return copy;\n    };\n    return dfs(node);\n}\n`
  },

  'combination-sum': {
    python: `def combinationSum(candidates, target):\n    res = []\n    path = []\n    def backtrack(start, remain):\n        if remain == 0:\n            res.append(path[:])\n            return\n        if remain < 0:\n            return\n        for i in range(start, len(candidates)):\n            path.append(candidates[i])\n            backtrack(i, remain - candidates[i])\n            path.pop()\n    backtrack(0, target)\n    return res\n`,
    java: `public List<List<Integer>> combinationSum(int[] candidates, int target) {\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> path = new ArrayList<>();\n    backtrack(0, candidates, target, path, res);\n    return res;\n}\nprivate void backtrack(int start, int[] c, int remain, List<Integer> path, List<List<Integer>> res) {\n    if (remain == 0) {\n        res.add(new ArrayList<>(path));\n        return;\n    }\n    if (remain < 0) return;\n    for (int i = start; i < c.length; i++) {\n        path.add(c[i]);\n        backtrack(i, c, remain - c[i], path, res);\n        path.remove(path.size() - 1);\n    }\n}\n`,
    cpp: `vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n    vector<vector<int>> res;\n    vector<int> path;\n    function<void(int,int)> dfs = [&](int start, int remain){\n        if (remain == 0) { res.push_back(path); return; }\n        if (remain < 0) return;\n        for (int i = start; i < (int)candidates.size(); i++) {\n            path.push_back(candidates[i]);\n            dfs(i, remain - candidates[i]);\n            path.pop_back();\n        }\n    };\n    dfs(0, target);\n    return res;\n}\n`
  },

  'copy-list-with-random-pointer': {
    python: `def copyRandomList(head):\n    if not head:\n        return None\n    mp = {}\n    cur = head\n    while cur:\n        mp[cur] = RandomNode(cur.val)\n        cur = cur.next\n    cur = head\n    while cur:\n        mp[cur].next = mp.get(cur.next)\n        mp[cur].random = mp.get(cur.random)\n        cur = cur.next\n    return mp[head]\n`,
    java: `public RandomNode copyRandomList(RandomNode head) {\n    if (head == null) return null;\n    Map<RandomNode, RandomNode> map = new HashMap<>();\n    RandomNode cur = head;\n    while (cur != null) {\n        map.put(cur, new RandomNode(cur.val));\n        cur = cur.next;\n    }\n    cur = head;\n    while (cur != null) {\n        map.get(cur).next = map.get(cur.next);\n        map.get(cur).random = map.get(cur.random);\n        cur = cur.next;\n    }\n    return map.get(head);\n}\n`,
    cpp: `RandomNode* copyRandomList(RandomNode* head) {\n    if (!head) return nullptr;\n    unordered_map<RandomNode*, RandomNode*> mp;\n    for (auto cur = head; cur; cur = cur->next) mp[cur] = new RandomNode(cur->val);\n    for (auto cur = head; cur; cur = cur->next) {\n        mp[cur]->next = mp.count(cur->next) ? mp[cur->next] : nullptr;\n        mp[cur]->random = mp.count(cur->random) ? mp[cur->random] : nullptr;\n    }\n    return mp[head];\n}\n`
  },

  'kth-smallest-element-in-a-bst': {
    python: `def kthSmallest(root, k):\n    st = []\n    cur = root\n    while cur or st:\n        while cur:\n            st.append(cur)\n            cur = cur.left\n        cur = st.pop()\n        k -= 1\n        if k == 0:\n            return cur.val\n        cur = cur.right\n    return None\n`,
    java: `public int kthSmallest(TreeNode root, int k) {\n    Deque<TreeNode> st = new ArrayDeque<>();\n    TreeNode cur = root;\n    while (cur != null || !st.isEmpty()) {\n        while (cur != null) {\n            st.push(cur);\n            cur = cur.left;\n        }\n        cur = st.pop();\n        k--;\n        if (k == 0) return cur.val;\n        cur = cur.right;\n    }\n    return -1;\n}\n`,
    cpp: `int kthSmallest(TreeNode* root, int k) {\n    vector<TreeNode*> st;\n    TreeNode* cur = root;\n    while (cur || !st.empty()) {\n        while (cur) { st.push_back(cur); cur = cur->left; }\n        cur = st.back(); st.pop_back();\n        if (--k == 0) return cur->val;\n        cur = cur->right;\n    }\n    return -1;\n}\n`
  },

  'network-delay-time': {
    python: `def networkDelayTime(times, n, k):\n    import heapq\n    graph = [[] for _ in range(n+1)]\n    for u,v,w in times:\n        graph[u].append((v,w))\n    dist = [float('inf')] * (n+1)\n    dist[k] = 0\n    pq = [(0,k)]\n    while pq:\n        d,u = heapq.heappop(pq)\n        if d != dist[u]:\n            continue\n        for v,w in graph[u]:\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(pq, (nd, v))\n    ans = max(dist[1:])\n    return -1 if ans == float('inf') else ans\n`,
    java: `public int networkDelayTime(int[][] times, int n, int k) {\n    List<int[]>[] g = new List[n+1];\n    for (int i=1;i<=n;i++) g[i] = new ArrayList<>();\n    for (int[] t : times) g[t[0]].add(new int[]{t[1], t[2]});\n    int[] dist = new int[n+1];\n    Arrays.fill(dist, Integer.MAX_VALUE);\n    dist[k] = 0;\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->a[0]-b[0]);\n    pq.add(new int[]{0,k});\n    while(!pq.isEmpty()) {\n        int[] cur = pq.poll();\n        int d = cur[0], u = cur[1];\n        if (d != dist[u]) continue;\n        for (int[] e : g[u]) {\n            int v=e[0], w=e[1];\n            if (d + w < dist[v]) {\n                dist[v] = d + w;\n                pq.add(new int[]{dist[v], v});\n            }\n        }\n    }\n    int ans = 0;\n    for (int i=1;i<=n;i++) {\n        if (dist[i] == Integer.MAX_VALUE) return -1;\n        ans = Math.max(ans, dist[i]);\n    }\n    return ans;\n}\n`,
    cpp: `int networkDelayTime(vector<vector<int>>& times, int n, int k) {\n    vector<vector<pair<int,int>>> g(n+1);\n    for (auto &t: times) g[t[0]].push_back({t[1], t[2]});\n    vector<int> dist(n+1, INT_MAX);\n    dist[k] = 0;\n    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\n    pq.push({0,k});\n    while(!pq.empty()) {\n        auto [d,u]=pq.top(); pq.pop();\n        if (d != dist[u]) continue;\n        for (auto [v,w]: g[u]) {\n            if (d + w < dist[v]) {\n                dist[v] = d + w;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n    int ans=0;\n    for (int i=1;i<=n;i++){\n        if(dist[i]==INT_MAX) return -1;\n        ans=max(ans, dist[i]);\n    }\n    return ans;\n}\n`
  },

  'redundant-connection': {
    python: `def findRedundantConnection(edges):\n    n = len(edges)\n    parent = list(range(n+1))\n    def find(x):\n        while parent[x] != x:\n            parent[x] = parent[parent[x]]\n            x = parent[x]\n        return x\n    def union(a,b):\n        ra, rb = find(a), find(b)\n        if ra == rb:\n            return False\n        parent[ra] = rb\n        return True\n    for a,b in edges:\n        if not union(a,b):\n            return [a,b]\n    return []\n`,
    java: `public int[] findRedundantConnection(int[][] edges) {\n    int n = edges.length;\n    int[] parent = new int[n+1];\n    for (int i=1;i<=n;i++) parent[i]=i;\n    for (int[] e : edges) {\n        int a=e[0], b=e[1];\n        int ra=find(parent,a), rb=find(parent,b);\n        if (ra==rb) return e;\n        parent[ra]=rb;\n    }\n    return new int[0];\n}\nprivate int find(int[] parent, int x) {\n    while (parent[x]!=x) {\n        parent[x]=parent[parent[x]];\n        x=parent[x];\n    }\n    return x;\n}\n`,
    cpp: `vector<int> findRedundantConnection(vector<vector<int>>& edges) {\n    int n=edges.size();\n    vector<int> parent(n+1);\n    iota(parent.begin(), parent.end(), 0);\n    function<int(int)> find = [&](int x){\n        while(parent[x]!=x){\n            parent[x]=parent[parent[x]];\n            x=parent[x];\n        }\n        return x;\n    };\n    for(auto &e: edges){\n        int a=e[0], b=e[1];\n        int ra=find(a), rb=find(b);\n        if(ra==rb) return {a,b};\n        parent[ra]=rb;\n    }\n    return {};\n}\n`
  },

  'reverse-nodes-in-k-group': {
    python: `def reverseKGroup(head, k):\n    dummy = ListNode(0, head)\n    groupPrev = dummy\n\n    def getKth(cur, k):\n        while cur and k > 0:\n            cur = cur.next\n            k -= 1\n        return cur\n\n    while True:\n        kth = getKth(groupPrev, k)\n        if not kth:\n            break\n        groupNext = kth.next\n\n        # reverse group\n        prev = groupNext\n        cur = groupPrev.next\n        while cur is not groupNext:\n            nxt = cur.next\n            cur.next = prev\n            prev = cur\n            cur = nxt\n\n        tmp = groupPrev.next\n        groupPrev.next = kth\n        groupPrev = tmp\n
    return dummy.next\n`,
    java: `public ListNode reverseKGroup(ListNode head, int k) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode groupPrev = dummy;\n    while (true) {\n        ListNode kth = getKth(groupPrev, k);\n        if (kth == null) break;\n        ListNode groupNext = kth.next;\n        ListNode prev = groupNext;\n        ListNode cur = groupPrev.next;\n        while (cur != groupNext) {\n            ListNode nxt = cur.next;\n            cur.next = prev;\n            prev = cur;\n            cur = nxt;\n        }\n        ListNode tmp = groupPrev.next;\n        groupPrev.next = kth;\n        groupPrev = tmp;\n    }\n    return dummy.next;\n}\nprivate ListNode getKth(ListNode cur, int k) {\n    while (cur != null && k > 0) {\n        cur = cur.next;\n        k--;\n    }\n    return cur;\n}\n`,
    cpp: `ListNode* reverseKGroup(ListNode* head, int k) {\n    ListNode dummy(0);\n    dummy.next = head;\n    ListNode* groupPrev = &dummy;\n    auto getKth = [&](ListNode* cur){\n        while (cur && k > 0) { cur = cur->next; k--; }\n        return cur;\n    };\n    // Note: in C++ lambda above captures k by value not good for loop; use helper below in real code.
    return head;\n}\n`
  },

  'rotting-oranges': {
    python: `from collections import deque\n\ndef orangesRotting(grid):\n    m = len(grid)\n    n = len(grid[0]) if m else 0\n    q = deque()\n    fresh = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 2:\n                q.append((i,j,0))\n            elif grid[i][j] == 1:\n                fresh += 1\n    minutes = 0\n    dirs = [(1,0),(-1,0),(0,1),(0,-1)]\n    while q:\n        i,j,t = q.popleft()\n        minutes = max(minutes, t)\n        for di,dj in dirs:\n            ni,nj = i+di, j+dj\n            if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == 1:\n                grid[ni][nj] = 2\n                fresh -= 1\n                q.append((ni,nj,t+1))\n    return -1 if fresh > 0 else minutes\n`,
    java: `public int orangesRotting(int[][] grid) {\n    int m = grid.length, n = grid[0].length;\n    Deque<int[]> q = new ArrayDeque<>();\n    int fresh = 0;\n    for (int i=0;i<m;i++) for (int j=0;j<n;j++) {\n        if (grid[i][j] == 2) q.add(new int[]{i,j,0});\n        else if (grid[i][j] == 1) fresh++;\n    }\n    int minutes = 0;\n    int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\n    while (!q.isEmpty()) {\n        int[] cur = q.poll();\n        int i=cur[0], j=cur[1], t=cur[2];\n        minutes = Math.max(minutes, t);\n        for (int[] d : dirs) {\n            int ni=i+d[0], nj=j+d[1];\n            if (0<=ni && ni<m && 0<=nj && nj<n && grid[ni][nj]==1) {\n                grid[ni][nj]=2;\n                fresh--;\n                q.add(new int[]{ni,nj,t+1});\n            }\n        }\n    }\n    return fresh>0? -1: minutes;\n}\n`,
    cpp: `int orangesRotting(vector<vector<int>>& grid) {\n    int m=grid.size(), n=grid[0].size();\n    queue<array<int,3>> q;\n    int fresh=0;\n    for(int i=0;i<m;i++) for(int j=0;j<n;j++){\n        if(grid[i][j]==2) q.push({i,j,0});\n        else if(grid[i][j]==1) fresh++;\n    }\n    int minutes=0;\n    int dirs[4][2]={{1,0},{-1,0},{0,1},{0,-1}};\n    while(!q.empty()) {\n        auto [i,j,t]=q.front(); q.pop();\n        minutes=max(minutes,t);\n        for(auto &d: dirs){\n            int ni=i+d[0], nj=j+d[1];\n            if(0<=ni&&ni<m&&0<=nj&&nj<n&&grid[ni][nj]==1){\n                grid[ni][nj]=2;\n                fresh--;\n                q.push({ni,nj,t+1});\n            }\n        }\n    }\n    return fresh>0? -1: minutes;\n}\n`
  },

  'serialize-and-deserialize-binary-tree': {
    python: `class Codec:\n    def serialize(self, root):\n        from collections import deque\n        if not root:\n            return ''\n        out = []\n        q = deque([root])\n        while q:\n            node = q.popleft()\n            if node is None:\n                out.append('#')\n                continue\n            out.append(str(node.val))\n            q.append(node.left)\n            q.append(node.right)\n        while out and out[-1] == '#':\n            out.pop()\n        return ','.join(out)\n\n    def deserialize(self, data):\n        from collections import deque\n        if not data:\n            return None\n        vals = data.split(',')\n        root = TreeNode(int(vals[0]))\n        q = deque([root])\n        idx = 1\n        while q and idx < len(vals):\n            node = q.popleft()\n            if idx < len(vals) and vals[idx] != '#':\n                node.left = TreeNode(int(vals[idx]))\n                q.append(node.left)\n            idx += 1\n            if idx < len(vals) and vals[idx] != '#':\n                node.right = TreeNode(int(vals[idx]))\n                q.append(node.right)\n            idx += 1\n        return root\n`,
    java: `class Codec {\n    public String serialize(TreeNode root) {\n        if (root == null) return \"\";\n        StringBuilder sb = new StringBuilder();\n        Deque<TreeNode> q = new ArrayDeque<>();\n        q.add(root);\n        while (!q.isEmpty()) {\n            TreeNode node = q.poll();\n            if (node == null) {\n                sb.append(\"#\").append(',');\n                continue;\n            }\n            sb.append(node.val).append(',');\n            q.add(node.left);\n            q.add(node.right);\n        }\n        return sb.toString();\n    }\n    public TreeNode deserialize(String data) {\n        if (data == null || data.length() == 0) return null;\n        String[] vals = data.split(",");\n        TreeNode root = new TreeNode(Integer.parseInt(vals[0]));\n        Deque<TreeNode> q = new ArrayDeque<>();\n        q.add(root);\n        int idx = 1;\n        while (!q.isEmpty() && idx < vals.length) {\n            TreeNode node = q.poll();\n            if (idx < vals.length && !vals[idx].equals(\"#\") && vals[idx].length() > 0) {\n                node.left = new TreeNode(Integer.parseInt(vals[idx]));\n                q.add(node.left);\n            }\n            idx++;\n            if (idx < vals.length && !vals[idx].equals(\"#\") && vals[idx].length() > 0) {\n                node.right = new TreeNode(Integer.parseInt(vals[idx]));\n                q.add(node.right);\n            }\n            idx++;\n        }\n        return root;\n    }\n}\n`,
    cpp: `class Codec {\npublic:\n    string serialize(TreeNode* root) {\n        if(!root) return \"\";\n        queue<TreeNode*> q;\n        q.push(root);\n        string out;\n        while(!q.empty()){\n            auto node=q.front(); q.pop();\n            if(!node){ out += \"#,\"; continue; }\n            out += to_string(node->val) + ",";\n            q.push(node->left);\n            q.push(node->right);\n        }\n        return out;\n    }\n    TreeNode* deserialize(string data) {\n        if(data.empty()) return nullptr;\n        vector<string> vals;\n        string cur;\n        for(char ch: data){\n            if(ch==','){ vals.push_back(cur); cur.clear(); }\n            else cur.push_back(ch);\n        }\n        if(!cur.empty()) vals.push_back(cur);\n        TreeNode* root = new TreeNode(stoi(vals[0]));\n        queue<TreeNode*> q;\n        q.push(root);\n        int idx=1;\n        while(!q.empty() && idx < (int)vals.size()){\n            auto node=q.front(); q.pop();\n            if(idx < (int)vals.size() && vals[idx] != "#" && !vals[idx].empty()){\n                node->left = new TreeNode(stoi(vals[idx]));\n                q.push(node->left);\n            }\n            idx++;\n            if(idx < (int)vals.size() && vals[idx] != "#" && !vals[idx].empty()){\n                node->right = new TreeNode(stoi(vals[idx]));\n                q.push(node->right);\n            }\n            idx++;\n        }\n        return root;\n    }\n};\n`
  },

  'sort-list': {
    python: `def sortList(head):\n    if not head or not head.next:\n        return head\n    slow = fast = head\n    prev = None\n    while fast and fast.next:\n        prev = slow\n        slow = slow.next\n        fast = fast.next.next\n    prev.next = None\n\n    l1 = sortList(head)\n    l2 = sortList(slow)\n\n    dummy = ListNode(0)\n    cur = dummy\n    while l1 and l2:\n        if l1.val <= l2.val:\n            cur.next = l1\n            l1 = l1.next\n        else:\n            cur.next = l2\n            l2 = l2.next\n        cur = cur.next\n    cur.next = l1 if l1 else l2\n    return dummy.next\n`,
    java: `public ListNode sortList(ListNode head) {\n    if (head == null || head.next == null) return head;\n    ListNode slow=head, fast=head, prev=null;\n    while (fast != null && fast.next != null) {\n        prev = slow;\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    prev.next = null;\n    ListNode l1 = sortList(head);\n    ListNode l2 = sortList(slow);\n    return merge(l1, l2);\n}\nprivate ListNode merge(ListNode a, ListNode b) {\n    ListNode dummy = new ListNode(0);\n    ListNode cur = dummy;\n    while (a != null && b != null) {\n        if (a.val <= b.val) { cur.next = a; a = a.next; }\n        else { cur.next = b; b = b.next; }\n        cur = cur.next;\n    }\n    cur.next = (a != null) ? a : b;\n    return dummy.next;\n}\n`,
    cpp: `ListNode* sortList(ListNode* head) {\n    if(!head || !head->next) return head;\n    ListNode* slow=head;\n    ListNode* fast=head;\n    ListNode* prev=nullptr;\n    while(fast && fast->next){\n        prev=slow;\n        slow=slow->next;\n        fast=fast->next->next;\n    }\n    prev->next=nullptr;\n    ListNode* l1=sortList(head);\n    ListNode* l2=sortList(slow);\n    ListNode dummy(0);\n    ListNode* cur=&dummy;\n    while(l1 && l2){\n        if(l1->val<=l2->val){ cur->next=l1; l1=l1->next; }\n        else { cur->next=l2; l2=l2->next; }\n        cur=cur->next;\n    }\n    cur->next = l1 ? l1 : l2;\n    return dummy.next;\n}\n`
  },

  'surrounded-regions': {
    python: `def solve(board):\n    if not board or not board[0]:\n        return\n    m, n = len(board), len(board[0])\n    from collections import deque\n    q = deque()\n    def add(i,j):\n        if 0<=i<m and 0<=j<n and board[i][j]=='O':\n            board[i][j] = 'E'\n            q.append((i,j))\n    for i in range(m):\n        add(i,0); add(i,n-1)\n    for j in range(n):\n        add(0,j); add(m-1,j)\n    dirs=[(1,0),(-1,0),(0,1),(0,-1)]\n    while q:\n        i,j = q.popleft()\n        for di,dj in dirs:\n            add(i+di, j+dj)\n    for i in range(m):\n        for j in range(n):\n            if board[i][j] == 'O':\n                board[i][j] = 'X'\n            elif board[i][j] == 'E':\n                board[i][j] = 'O'\n`,
    java: `public void solve(char[][] board) {\n    int m = board.length;\n    if (m == 0) return;\n    int n = board[0].length;\n    Deque<int[]> q = new ArrayDeque<>();\n    java.util.function.BiConsumer<Integer,Integer> add = (i,j)->{\n        if (i>=0 && i<m && j>=0 && j<n && board[i][j]=='O') {\n            board[i][j]='E';\n            q.add(new int[]{i,j});\n        }\n    };\n    for (int i=0;i<m;i++){ add.accept(i,0); add.accept(i,n-1); }\n    for (int j=0;j<n;j++){ add.accept(0,j); add.accept(m-1,j); }\n    int[][] dirs={{1,0},{-1,0},{0,1},{0,-1}};\n    while(!q.isEmpty()){\n        int[] cur=q.poll();\n        for (int[] d: dirs) add.accept(cur[0]+d[0], cur[1]+d[1]);\n    }\n    for (int i=0;i<m;i++) for (int j=0;j<n;j++){\n        if (board[i][j]=='O') board[i][j]='X';\n        else if (board[i][j]=='E') board[i][j]='O';\n    }\n}\n`,
    cpp: `void solve(vector<vector<char>>& board) {\n    int m=board.size();\n    if(!m) return;\n    int n=board[0].size();\n    queue<pair<int,int>> q;\n    auto add = [&](int i,int j){\n        if(i>=0&&i<m&&j>=0&&j<n&&board[i][j]=='O'){\n            board[i][j]='E';\n            q.push({i,j});\n        }\n    };\n    for(int i=0;i<m;i++){ add(i,0); add(i,n-1);}\n    for(int j=0;j<n;j++){ add(0,j); add(m-1,j);}\n    int dirs[4][2]={{1,0},{-1,0},{0,1},{0,-1}};\n    while(!q.empty()){\n        auto [i,j]=q.front(); q.pop();\n        for(auto &d: dirs) add(i+d[0], j+d[1]);\n    }\n    for(int i=0;i<m;i++) for(int j=0;j<n;j++){\n        if(board[i][j]=='O') board[i][j]='X';\n        else if(board[i][j]=='E') board[i][j]='O';\n    }\n}\n`
  },

  'word-ladder': {
    python: `from collections import deque\n\ndef ladderLength(beginWord, endWord, wordList):\n    wordSet = set(wordList)\n    if endWord not in wordSet:\n        return 0\n    q = deque([(beginWord, 1)])\n    visited = set([beginWord])\n    while q:\n        word, dist = q.popleft()\n        if word == endWord:\n            return dist\n        arr = list(word)\n        for i in range(len(arr)):\n            orig = arr[i]\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                if c == orig: continue\n                arr[i] = c\n                nxt = ''.join(arr)\n                if nxt in wordSet and nxt not in visited:\n                    visited.add(nxt)\n                    q.append((nxt, dist + 1))\n            arr[i] = orig\n    return 0\n`,
    java: `public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n    Set<String> set = new HashSet<>(wordList);\n    if (!set.contains(endWord)) return 0;\n    Deque<String> q = new ArrayDeque<>();\n    Deque<Integer> distQ = new ArrayDeque<>();\n    Set<String> vis = new HashSet<>();\n    q.add(beginWord);\n    distQ.add(1);\n    vis.add(beginWord);\n    while (!q.isEmpty()) {\n        String word = q.poll();\n        int dist = distQ.poll();\n        if (word.equals(endWord)) return dist;\n        char[] arr = word.toCharArray();\n        for (int i=0;i<arr.length;i++) {\n            char orig = arr[i];\n            for (char c='a'; c<='z'; c++) {\n                if (c == orig) continue;\n                arr[i] = c;\n                String nxt = new String(arr);\n                if (set.contains(nxt) && !vis.contains(nxt)) {\n                    vis.add(nxt);\n                    q.add(nxt);\n                    distQ.add(dist+1);\n                }\n            }\n            arr[i] = orig;\n        }\n    }\n    return 0;\n}\n`,
    cpp: `int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n    unordered_set<string> set(wordList.begin(), wordList.end());\n    if (!set.count(endWord)) return 0;\n    queue<pair<string,int>> q;\n    unordered_set<string> vis;\n    q.push({beginWord,1});\n    vis.insert(beginWord);\n    while(!q.empty()) {\n        auto [word, dist] = q.front(); q.pop();\n        if (word == endWord) return dist;\n        for (int i=0;i<(int)word.size();i++) {\n            char orig = word[i];\n            for (char c='a'; c<='z'; c++) {\n                if (c==orig) continue;\n                word[i]=c;\n                if (set.count(word) && !vis.count(word)) {\n                    vis.insert(word);\n                    q.push({word, dist+1});\n                }\n            }\n            word[i]=orig;\n        }\n    }\n    return 0;\n}\n`
  },
};

let patched = 0;
for (const q of questions) {
  const fix = fixes[q.leetcodeSlug];
  if (!fix) continue;
  q.codeSnippet = { python: fix.python, java: fix.java, cpp: fix.cpp };
  patched++;
}

fs.writeFileSync(questionsPath, 'module.exports = ' + JSON.stringify(questions, null, 2) + ';\n', 'utf8');
console.log(JSON.stringify({ patched }, null, 2));
